/*! For license information please see lib-non_max_suppression_impl-ec0b3862.4301bf3c84710e38e180.js.LICENSE.txt */
"use strict";(self.webpackChunktheremin=self.webpackChunktheremin||[]).push([[615],{9839:(t,e,n)=>{n.d(e,{$:()=>ii,A:()=>$n,B:()=>rt,C:()=>ws,D:()=>xs,E:()=>fs,F:()=>Hn,G:()=>Ln,H:()=>z,I:()=>qt,J:()=>ct,K:()=>_,L:()=>U,M:()=>j,N:()=>q,O:()=>Fe,P:()=>H,Q:()=>W,R:()=>Mt,S:()=>G,T:()=>Jr,U:()=>V,V:()=>K,W:()=>J,X:()=>Z,Y:()=>X,Z:()=>Q,_:()=>si,a:()=>Ei,a$:()=>Ie,a0:()=>Y,a1:()=>et,a2:()=>Es,a3:()=>dt,a4:()=>tn,a5:()=>xn,a6:()=>st,a7:()=>Ht,a8:()=>ot,a9:()=>it,aA:()=>Vt,aB:()=>Kt,aC:()=>Qt,aD:()=>te,aE:()=>ne,aF:()=>re,aG:()=>se,aH:()=>ue,aI:()=>oe,aJ:()=>ie,aK:()=>Zr,aL:()=>Te,aM:()=>on,aN:()=>de,aO:()=>In,aP:()=>pi,aQ:()=>ae,aR:()=>le,aS:()=>he,aT:()=>ge,aU:()=>me,aV:()=>we,aW:()=>fe,aX:()=>be,aY:()=>ke,aZ:()=>ve,a_:()=>Ee,aa:()=>Tn,ab:()=>lt,ac:()=>ht,ad:()=>ft,ae:()=>pt,af:()=>mt,ag:()=>bt,ah:()=>kt,ai:()=>vt,aj:()=>It,ak:()=>St,al:()=>xt,am:()=>$t,an:()=>Po,ao:()=>Lt,ap:()=>Xe,aq:()=>Rn,ar:()=>Dt,as:()=>Nt,at:()=>Pt,au:()=>Ct,av:()=>Ot,aw:()=>Eo,ax:()=>Ut,ay:()=>zt,az:()=>Wt,b:()=>hi,b$:()=>kn,b0:()=>Se,b1:()=>Be,b2:()=>De,b3:()=>Ne,b4:()=>hn,b5:()=>Le,b6:()=>Ce,b7:()=>Oe,b8:()=>_e,b9:()=>Ue,bA:()=>Mi,bB:()=>$i,bC:()=>Zo,bD:()=>On,bE:()=>Bi,bF:()=>ri,bG:()=>Ai,bH:()=>Tt,bI:()=>Bt,bJ:()=>_n,bK:()=>Cn,bL:()=>Et,bM:()=>jt,bN:()=>Pn,bO:()=>Ae,bP:()=>Ri,bQ:()=>Me,bR:()=>Li,bS:()=>$e,bT:()=>Ni,bU:()=>We,bV:()=>qe,bW:()=>An,bX:()=>dn,bY:()=>fn,bZ:()=>gn,b_:()=>pn,ba:()=>Ke,bb:()=>Je,bc:()=>Ze,bd:()=>Ye,be:()=>Gr,bf:()=>rn,bg:()=>en,bh:()=>nn,bi:()=>cn,bj:()=>_t,bk:()=>Zt,bl:()=>un,bm:()=>an,bn:()=>yn,bo:()=>Re,bp:()=>bn,bq:()=>Sn,br:()=>Bn,bs:()=>Mn,bt:()=>Dn,bu:()=>Ti,bv:()=>Oo,bw:()=>Qe,bx:()=>mn,by:()=>Gt,bz:()=>gt,c:()=>So,c$:()=>di,c0:()=>vn,c1:()=>En,c2:()=>ps,c3:()=>No,c4:()=>Rr,c5:()=>gi,c6:()=>rs,c7:()=>Pr,c8:()=>Fr,c9:()=>o,cA:()=>wt,cB:()=>wi,cC:()=>At,cD:()=>Vo,cE:()=>Ft,cF:()=>Rt,cG:()=>Xt,cH:()=>Yt,cI:()=>ce,cJ:()=>ye,cK:()=>pe,cL:()=>je,cM:()=>Ve,cN:()=>Ge,cO:()=>He,cP:()=>_o,cQ:()=>sn,cR:()=>wn,cS:()=>Nn,cT:()=>Fn,cU:()=>Vn,cV:()=>_s,cW:()=>Ps,cX:()=>Rs,cY:()=>Ns,cZ:()=>Ls,c_:()=>Cs,ca:()=>s,cb:()=>Uo,cc:()=>Lr,cd:()=>Cr,ce:()=>Un,cf:()=>ms,cg:()=>Wo,ch:()=>Jt,ci:()=>ut,cj:()=>ee,ck:()=>Pe,cl:()=>xe,cm:()=>ze,cn:()=>yi,co:()=>bi,cp:()=>mi,cq:()=>ss,cr:()=>ln,cs:()=>Ko,ct:()=>Jo,cu:()=>nt,cv:()=>tt,cw:()=>at,cx:()=>oi,cy:()=>Qo,cz:()=>yt,d:()=>Ss,d0:()=>fi,d1:()=>Lo,d2:()=>Xo,d3:()=>Co,d4:()=>jn,d5:()=>As,d6:()=>Fo,d7:()=>Mo,d8:()=>Bo,d9:()=>js,dB:()=>Ho,da:()=>Us,db:()=>Ao,dc:()=>wo,dd:()=>mo,de:()=>bo,df:()=>yo,dg:()=>is,e:()=>h,f:()=>Si,g:()=>jo,h:()=>ai,i:()=>Io,j:()=>ci,k:()=>qo,l:()=>ui,m:()=>Go,n:()=>Ro,o:()=>qs,p:()=>vi,q:()=>$s,r:()=>Ii,s:()=>li,t:()=>Ts,u:()=>zs,v:()=>zo,w:()=>Is,x:()=>vs,y:()=>os,z:()=>ki}),n(5389),n(3807);var r=n(5912);class s{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class o{refCount(t){return i("refCount")}incRef(t){return i("incRef")}timerAvailable(){return!0}time(t){return i("time")}read(t){return i("read")}readSync(t){return i("readSync")}readToGPU(t,e){return i("readToGPU")}numDataIds(){return i("numDataIds")}disposeData(t,e){return i("disposeData")}write(t,e,n){return i("write")}move(t,e,n,r,s){return i("move")}memory(){return i("memory")}floatPrecision(){return i("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return i("dispose")}}function i(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}class a{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=l,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(h().getBool("IS_TEST")||h().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];h().getBool("IS_TEST")||h().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if((0,r.i)(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)}))}}function l(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")))),e}function h(){return u}let u=null;function c(){throw new Error("setTimeout has not been defined")}function d(){throw new Error("clearTimeout has not been defined")}var f,g=c,p=d;function m(t){if(g===setTimeout)return setTimeout(t,0);if((g===c||!g)&&setTimeout)return g=setTimeout,setTimeout(t,0);try{return g(t,0)}catch(e){try{return g.call(null,t,0)}catch(e){return g.call(this,t,0)}}}"function"==typeof(f="undefined"!=typeof window?window:"undefined"!=typeof self?self:{}).setTimeout&&(g=setTimeout),"function"==typeof f.clearTimeout&&(p=clearTimeout);var y,w=[],b=!1,k=-1;function v(){b&&y&&(b=!1,y.length?w=y.concat(w):k=-1,w.length&&E())}function E(){if(!b){var t=m(v);b=!0;for(var e=w.length;e;){for(y=w,w=[];++k<e;)y&&y[k].run();k=-1,e=w.length}y=null,b=!1,function(t){if(p===clearTimeout)return clearTimeout(t);if((p===d||!p)&&clearTimeout)return p=clearTimeout,clearTimeout(t);try{p(t)}catch(e){try{return p.call(null,t)}catch(e){return p.call(this,t)}}}(t)}}function I(t,e){this.fun=t,this.array=e}function S(){}I.prototype.run=function(){this.fun.apply(null,this.array)};var x=S,T=S,B=S,A=S,$=S,M=S,D=S,F=f.performance||{},R=F.now||F.mozNow||F.msNow||F.oNow||F.webkitNow||function(){return(new Date).getTime()},N=new Date,L={nextTick:function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];w.push(new I(t,e)),1!==w.length||b||m(E)},title:"browser",browser:!0,env:{NODE_ENV:"production"},argv:[],version:"",versions:{},on:x,addListener:T,once:B,off:A,removeListener:$,removeAllListeners:M,emit:D,binding:function(t){throw new Error("process.binding is not supported")},cwd:function(){return"/"},chdir:function(t){throw new Error("process.chdir is not supported")},umask:function(){return 0},hrtime:function(t){var e=.001*R.call(F),n=Math.floor(e),r=Math.floor(e%1*1e9);return t&&(n-=t[0],(r-=t[1])<0&&(n--,r+=1e9)),[n,r]},platform:"browser",release:{},config:{},uptime:function(){return(new Date-N)/1e3}};let P;function C(){if(null==P){let t;if("undefined"!=typeof window)t=window;else if(void 0!==n.g)t=n.g;else if(void 0!==L)t=L;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}P=t}return P}function O(t,e){const n=function(){const t=C();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const _="Abs",U="Acos",j="Acosh",z="Add",q="AddN",H="All",W="Any",G="ArgMax",V="ArgMin",K="Asin",J="Asinh",Z="Atan",Q="Atanh",X="Atan2",Y="AvgPool",tt="AvgPoolGrad",et="AvgPool3D",nt="AvgPool3DGrad",rt="BatchMatMul",st="BatchToSpaceND",ot="Bincount",it="BroadcastArgs",at="Cast",lt="Ceil",ht="ClipByValue",ut="Complex",ct="ComplexAbs",dt="Concat",ft="Conv2D",gt="Conv2DBackpropFilter",pt="Conv2DBackpropInput",mt="Conv3D",yt="Conv3DBackpropFilterV2",wt="Conv3DBackpropInputV2",bt="Cos",kt="Cosh",vt="Cumsum",Et="CropAndResize",It="DenseBincount",St="DepthToSpace",xt="DepthwiseConv2dNative",Tt="DepthwiseConv2dNativeBackpropFilter",Bt="DepthwiseConv2dNativeBackpropInput",At="Diag",$t="Dilation2D",Mt="RealDiv",Dt="Einsum",Ft="Elu",Rt="EluGrad",Nt="Erf",Lt="Equal",Pt="Exp",Ct="ExpandDims",Ot="Expm1",_t="FFT",Ut="Fill",jt="FlipLeftRight",zt="Floor",qt="FloorDiv",Ht="FusedBatchNorm",Wt="GatherV2",Gt="GatherNd",Vt="Greater",Kt="GreaterEqual",Jt="Identity",Zt="IFFT",Qt="Imag",Xt="IsFinite",Yt="IsInf",te="IsNan",ee="LeakyRelu",ne="Less",re="LessEqual",se="LinSpace",oe="Log",ie="Log1p",ae="LogicalAnd",le="LogicalNot",he="LogicalOr",ue="LRN",ce="LRNGrad",de="Max",fe="Maximum",ge="MaxPool",pe="MaxPoolGrad",me="MaxPool3D",ye="MaxPool3DGrad",we="MaxPoolWithArgmax",be="Mean",ke="Min",ve="Minimum",Ee="MirrorPad",Ie="Mod",Se="Multinomial",xe="Multiply",Te="Neg",Be="NotEqual",Ae="NonMaxSuppressionV3",$e="NonMaxSuppressionV4",Me="NonMaxSuppressionV5",De="OnesLike",Fe="OneHot",Re="Pack",Ne="PadV2",Le="Pow",Pe="Prelu",Ce="Prod",Oe="Range",_e="Real",Ue="Reciprocal",je="Relu",ze="Reshape",qe="ResizeNearestNeighbor",He="ResizeNearestNeighborGrad",We="ResizeBilinear",Ge="ResizeBilinearGrad",Ve="Relu6",Ke="Reverse",Je="Round",Ze="Rsqrt",Qe="ScatterNd",Xe="Select",Ye="Selu",tn="Slice",en="Sin",nn="Sinh",rn="Sign",sn="Sigmoid",on="Softplus",an="Sqrt",ln="Sum",hn="SpaceToBatchND",un="SplitV",cn="Softmax",dn="SparseFillEmptyRows",fn="SparseReshape",gn="SparseSegmentMean",pn="SparseSegmentSum",mn="SparseToDense",yn="SquaredDifference",wn="Square",bn="StridedSlice",kn="StringNGrams",vn="StringSplit",En="StringToHashBucketFast",In="Sub",Sn="Tan",xn="Tanh",Tn="Tile",Bn="TopK",An="Transform",$n="Transpose",Mn="Unique",Dn="Unpack",Fn="UnsortedSegmentSum",Rn="ZerosLike",Nn="Step",Ln="FromPixels",Pn="RotateWithOffset",Cn="_FusedMatMul",On="FusedConv2D",_n="FusedDepthwiseConv2D";function Un(...t){h().getBool("IS_TEST")||h().getBool("PROD")||console.warn(...t)}function jn(...t){h().getBool("IS_TEST")||h().getBool("PROD")||console.log(...t)}const zn=O("kernelRegistry",(()=>new Map)),qn=O("gradRegistry",(()=>new Map));function Hn(t,e){const n=Kn(t,e);return zn.get(n)}function Wn(t){return qn.get(t)}function Gn(t){const e=zn.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===t&&n.push(i)}return n}function Vn(t){const{kernelName:e,backendName:n}=t,r=Kn(e,n);zn.has(r)&&Un(`The kernel '${e}' for backend '${n}' is already registered`),zn.set(r,t)}function Kn(t,e){return`${e}_${t}`}var Jn=Qn,Zn=null;try{Zn=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function Qn(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function Xn(t){return!0===(t&&t.__isLong__)}Qn.prototype.__isLong__,Object.defineProperty(Qn.prototype,"__isLong__",{value:!0}),Qn.isLong=Xn;var Yn={},tr={};function er(t,e){var n,r,s;return e?(s=0<=(t>>>=0)&&t<256)&&(r=tr[t])?r:(n=rr(t,(0|t)<0?-1:0,!0),s&&(tr[t]=n),n):(s=-128<=(t|=0)&&t<128)&&(r=Yn[t])?r:(n=rr(t,t<0?-1:0,!1),s&&(Yn[t]=n),n)}function nr(t,e){if(isNaN(t))return e?dr:cr;if(e){if(t<0)return dr;if(t>=lr)return yr}else{if(t<=-hr)return wr;if(t+1>=hr)return mr}return t<0?nr(-t,e).neg():rr(t%ar|0,t/ar|0,e)}function rr(t,e,n){return new Qn(t,e,n)}Qn.fromInt=er,Qn.fromNumber=nr,Qn.fromBits=rr;var sr=Math.pow;function or(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return cr;if("number"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return or(t.substring(1),e,n).neg();for(var s=nr(sr(n,8)),o=cr,i=0;i<t.length;i+=8){var a=Math.min(8,t.length-i),l=parseInt(t.substring(i,i+a),n);if(a<8){var h=nr(sr(n,a));o=o.mul(h).add(nr(l))}else o=(o=o.mul(s)).add(nr(l))}return o.unsigned=e,o}function ir(t,e){return"number"==typeof t?nr(t,e):"string"==typeof t?or(t,e):rr(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}Qn.fromString=or,Qn.fromValue=ir;var ar=4294967296,lr=ar*ar,hr=lr/2,ur=er(1<<24),cr=er(0);Qn.ZERO=cr;var dr=er(0,!0);Qn.UZERO=dr;var fr=er(1);Qn.ONE=fr;var gr=er(1,!0);Qn.UONE=gr;var pr=er(-1);Qn.NEG_ONE=pr;var mr=rr(-1,2147483647,!1);Qn.MAX_VALUE=mr;var yr=rr(-1,-1,!0);Qn.MAX_UNSIGNED_VALUE=yr;var wr=rr(0,-2147483648,!1);Qn.MIN_VALUE=wr;var br=Qn.prototype;br.toInt=function(){return this.unsigned?this.low>>>0:this.low},br.toNumber=function(){return this.unsigned?(this.high>>>0)*ar+(this.low>>>0):this.high*ar+(this.low>>>0)},br.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(wr)){var e=nr(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var s=nr(sr(t,6),this.unsigned),o=this,i="";;){var a=o.div(s),l=(o.sub(a.mul(s)).toInt()>>>0).toString(t);if((o=a).isZero())return l+i;for(;l.length<6;)l="0"+l;i=""+l+i}},br.getHighBits=function(){return this.high},br.getHighBitsUnsigned=function(){return this.high>>>0},br.getLowBits=function(){return this.low},br.getLowBitsUnsigned=function(){return this.low>>>0},br.getNumBitsAbs=function(){if(this.isNegative())return this.eq(wr)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},br.isZero=function(){return 0===this.high&&0===this.low},br.eqz=br.isZero,br.isNegative=function(){return!this.unsigned&&this.high<0},br.isPositive=function(){return this.unsigned||this.high>=0},br.isOdd=function(){return 1==(1&this.low)},br.isEven=function(){return 0==(1&this.low)},br.equals=function(t){return Xn(t)||(t=ir(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low},br.eq=br.equals,br.notEquals=function(t){return!this.eq(t)},br.neq=br.notEquals,br.ne=br.notEquals,br.lessThan=function(t){return this.comp(t)<0},br.lt=br.lessThan,br.lessThanOrEqual=function(t){return this.comp(t)<=0},br.lte=br.lessThanOrEqual,br.le=br.lessThanOrEqual,br.greaterThan=function(t){return this.comp(t)>0},br.gt=br.greaterThan,br.greaterThanOrEqual=function(t){return this.comp(t)>=0},br.gte=br.greaterThanOrEqual,br.ge=br.greaterThanOrEqual,br.compare=function(t){if(Xn(t)||(t=ir(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},br.comp=br.compare,br.negate=function(){return!this.unsigned&&this.eq(wr)?wr:this.not().add(fr)},br.neg=br.negate,br.add=function(t){Xn(t)||(t=ir(t));var e=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,o=t.high>>>16,i=65535&t.high,a=t.low>>>16,l=0,h=0,u=0,c=0;return u+=(c+=s+(65535&t.low))>>>16,h+=(u+=r+a)>>>16,l+=(h+=n+i)>>>16,l+=e+o,rr((u&=65535)<<16|(c&=65535),(l&=65535)<<16|(h&=65535),this.unsigned)},br.subtract=function(t){return Xn(t)||(t=ir(t)),this.add(t.neg())},br.sub=br.subtract,br.multiply=function(t){if(this.isZero())return cr;if(Xn(t)||(t=ir(t)),Zn)return rr(Zn.mul(this.low,this.high,t.low,t.high),Zn.get_high(),this.unsigned);if(t.isZero())return cr;if(this.eq(wr))return t.isOdd()?wr:cr;if(t.eq(wr))return this.isOdd()?wr:cr;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(ur)&&t.lt(ur))return nr(this.toNumber()*t.toNumber(),this.unsigned);var e=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,o=t.high>>>16,i=65535&t.high,a=t.low>>>16,l=65535&t.low,h=0,u=0,c=0,d=0;return c+=(d+=s*l)>>>16,u+=(c+=r*l)>>>16,c&=65535,u+=(c+=s*a)>>>16,h+=(u+=n*l)>>>16,u&=65535,h+=(u+=r*a)>>>16,u&=65535,h+=(u+=s*i)>>>16,h+=e*l+n*a+r*i+s*o,rr((c&=65535)<<16|(d&=65535),(h&=65535)<<16|(u&=65535),this.unsigned)},br.mul=br.multiply,br.divide=function(t){if(Xn(t)||(t=ir(t)),t.isZero())throw Error("division by zero");var e,n,r;if(Zn)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?rr((this.unsigned?Zn.div_u:Zn.div_s)(this.low,this.high,t.low,t.high),Zn.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?dr:cr;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return dr;if(t.gt(this.shru(1)))return gr;r=dr}else{if(this.eq(wr))return t.eq(fr)||t.eq(pr)?wr:t.eq(wr)?fr:(e=this.shr(1).div(t).shl(1)).eq(cr)?t.isNegative()?fr:pr:(n=this.sub(t.mul(e)),r=e.add(n.div(t)));if(t.eq(wr))return this.unsigned?dr:cr;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();r=cr}for(n=this;n.gte(t);){e=Math.max(1,Math.floor(n.toNumber()/t.toNumber()));for(var s=Math.ceil(Math.log(e)/Math.LN2),o=s<=48?1:sr(2,s-48),i=nr(e),a=i.mul(t);a.isNegative()||a.gt(n);)a=(i=nr(e-=o,this.unsigned)).mul(t);i.isZero()&&(i=fr),r=r.add(i),n=n.sub(a)}return r},br.div=br.divide,br.modulo=function(t){return Xn(t)||(t=ir(t)),Zn?rr((this.unsigned?Zn.rem_u:Zn.rem_s)(this.low,this.high,t.low,t.high),Zn.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},br.mod=br.modulo,br.rem=br.modulo,br.not=function(){return rr(~this.low,~this.high,this.unsigned)},br.and=function(t){return Xn(t)||(t=ir(t)),rr(this.low&t.low,this.high&t.high,this.unsigned)},br.or=function(t){return Xn(t)||(t=ir(t)),rr(this.low|t.low,this.high|t.high,this.unsigned)},br.xor=function(t){return Xn(t)||(t=ir(t)),rr(this.low^t.low,this.high^t.high,this.unsigned)},br.shiftLeft=function(t){return Xn(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?rr(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):rr(0,this.low<<t-32,this.unsigned)},br.shl=br.shiftLeft,br.shiftRight=function(t){return Xn(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?rr(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):rr(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},br.shr=br.shiftRight,br.shiftRightUnsigned=function(t){if(Xn(t)&&(t=t.toInt()),0==(t&=63))return this;var e=this.high;return t<32?rr(this.low>>>t|e<<32-t,e>>>t,this.unsigned):rr(32===t?e:e>>>t-32,0,this.unsigned)},br.shru=br.shiftRightUnsigned,br.shr_u=br.shiftRightUnsigned,br.toSigned=function(){return this.unsigned?rr(this.low,this.high,!1):this},br.toUnsigned=function(){return this.unsigned?this:rr(this.low,this.high,!0)},br.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},br.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},br.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},Qn.fromBytes=function(t,e,n){return n?Qn.fromBytesLE(t,e):Qn.fromBytesBE(t,e)},Qn.fromBytesLE=function(t,e){return new Qn(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},Qn.fromBytesBE=function(t,e){return new Qn(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)};const kr=Jn||Object.freeze(Object.assign(Object.create(null),Jn,{default:Jn}));function vr(t){return kr.fromString(t,!0,16)}const Er=vr("c3a5c85c97cb3127"),Ir=vr("b492b66fbe98f273"),Sr=vr("9ae16a3b2f90404f");function xr(t){return t.xor(t.shru(47))}function Tr(t,e,n){const r=t.slice(e,e+n);return kr.fromBytes(Array.from(r),!0,!0)}function Br(t,e){return Tr(t,e,8)}function Ar(t,e){return Tr(t,e,4)}function $r(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function Mr(t,e,n=vr("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Dr(t,e,n,r){return function(t,e,n,r,s,o){s=s.add(t),o=$r(o.add(s).add(r),21);const i=s;return s=(s=s.add(e)).add(n),o=o.add($r(s,44)),[s.add(r),o.add(i)]}(Br(t,e),Br(t,e+8),Br(t,e+16),Br(t,e+24),n,r)}function Fr(t,e=t.length){const n=kr.fromNumber(81,!0);if(e<=32)return e<=16?function(t,e=t.length){if(e>=8){const n=Sr.add(2*e),r=Br(t,0).add(Sr),s=Br(t,e-8);return Mr($r(s,37).mul(n).add(r),$r(r,25).add(s).mul(n),n)}if(e>=4){const n=Sr.add(2*e);return Mr(Ar(t,0).shl(3).add(e),Ar(t,e-4),n)}if(e>0){const n=t[0]+(t[e>>1]<<8),r=e+(t[e-1]<<2);return xr(Sr.mul(n).xor(Er.mul(r))).mul(Sr)}return Sr}(t,e):function(t,e=t.length){const n=Sr.add(2*e),r=Br(t,0).mul(Ir),s=Br(t,8),o=Br(t,e-8).mul(n),i=Br(t,e-16).mul(Sr);return Mr($r(r.add(s),43).add($r(o,30)).add(i),r.add($r(s.add(Sr),18)).add(o),n)}(t,e);if(e<=64)return function(t,e=t.length){const n=Sr.add(2*e),r=Br(t,0).mul(Sr),s=Br(t,8),o=Br(t,e-8).mul(n),i=Br(t,e-16).mul(Sr),a=$r(r.add(s),43).add($r(o,30)).add(i),l=Mr(a,r.add($r(s.add(Sr),18)).add(o),n),h=Br(t,16).mul(n),u=Br(t,24),c=a.add(Br(t,e-32)).mul(n),d=l.add(Br(t,e-24)).mul(n);return Mr($r(h.add(u),43).add($r(c,30)).add(d),h.add($r(u.add(r),18)).add(c),n)}(t,e);let r=n,s=n.mul(Ir).add(113),o=xr(s.mul(Sr).add(113)).mul(Sr),i=[kr.UZERO,kr.UZERO],a=[kr.UZERO,kr.UZERO];r=r.mul(Sr).add(Br(t,0));let l=0;const h=64*(e-1>>6),u=h+(e-1&63)-63;do{r=$r(r.add(s).add(i[0]).add(Br(t,l+8)),37).mul(Ir),s=$r(s.add(i[1]).add(Br(t,l+48)),42).mul(Ir),r=r.xor(a[1]),s=s.add(i[0]).add(Br(t,l+40)),o=$r(o.add(a[0]),33).mul(Ir),i=Dr(t,l,i[1].mul(Ir),r.add(a[0])),a=Dr(t,l+32,o.add(a[1]),s.add(Br(t,l+16))),[o,r]=[r,o],l+=64}while(l!==h);const c=Ir.add(o.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=$r(r.add(s).add(i[0]).add(Br(t,l+8)),37).mul(c),s=$r(s.add(i[1]).add(Br(t,l+48)),42).mul(c),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(Br(t,l+40))),o=$r(o.add(a[0]),33).mul(c),i=Dr(t,l,i[1].mul(c),r.add(a[0])),a=Dr(t,l+32,o.add(a[1]),s.add(Br(t,l+16))),[o,r]=[r,o],Mr(Mr(i[0],a[0],c).add(xr(s).mul(Er)).add(o),Mr(i[1],a[1],c).add(r),c)}function Rr(t,e){return"string"===e?Pr(t):Nr([t],e)}function Nr(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=(0,r.f)(t)),h().getBool("DEBUG")&&(0,r.c)(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function Lr(){return h().platform.now()}function Pr(t,e="utf-8"){return e=e||"utf-8",h().platform.encode(t,e)}function Cr(t,e="utf-8"){return e=e||"utf-8",h().platform.decode(t,e)}r.s,r.d,r.e,r.n,r.g,r.h,r.r,r.j,r.a,r.k,r.l,r.f,r.m,r.o,r.b,r.p,r.q,r.u,r.v,r.w,r.x,r.y,r.z,r.A,r.B,r.C,r.c,r.D,r.E,r.F,r.G,r.H,r.I,r.J,r.K,r.L,r.M,r.N,r.O,r.t,r.P,r.Q,r.R,r.S,r.T,r.U,r.i;class Or{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Ur)}profileKernel(t,e,n){let r;const s=()=>{r=n()};let o;const i=Lr();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(const t of r)t.dataSync();o=Promise.resolve({kernelMs:Lr()-i})}if(h().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let e=0;e<r.length;e++){const n=r[e];n.data().then((e=>{_r(e,n.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:o.then((t=>t.kernelMs)),extraInfo:o.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:s,extraInfo:o}=t;n.forEach((t=>{Promise.all([t.data(),r,o]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],s,n[2])}))}))}}function _r(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class Ur{logKernelProfile(t,e,n,s,o,i){const a="number"==typeof s?(0,r.w)(`${s}ms`,9):s.error,l=(0,r.w)(t,25),h=e.rank,u=e.size,c=(0,r.w)(e.shape.toString(),14);let d="";for(const t in o){const n=o[t];if(null!=n){const r=n.shape||e.shape,s=r.length;d+=`${t}: ${s}D ${s>0?r:""} `}}console.log(`%c${l}\t%c${a}\t%c${h}D ${c}\t%c${u}\t%c${d}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function jr(t,e,n,s){const o=(0,r.O)(e),i=function(t,e,n,s){const o=(0,r.m)(e),i=s[s.length-1],a=new Array(i).fill(0),l=e.length,h="complex64"===n?Wr(t):t;if(l>1)for(let t=0;t<o/i;t++){const e=t*i;for(let t=0;t<i;t++)a[t]=Math.max(a[t],zr(h[e+t],0,n).length)}return a}(t,e,n,o),a=e.length,l=Hr(t,e,n,o,i),h=["Tensor"];return s&&(h.push(`  dtype: ${n}`),h.push(`  rank: ${a}`),h.push(`  shape: [${e}]`),h.push("  values:")),h.push(l.map((t=>"    "+t)).join("\n")),h.join("\n")}function zr(t,e,n){let s;return s=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:(0,r.I)(t)?`'${t}'`:"bool"===n?qr(t):parseFloat(t.toFixed(7)).toString(),(0,r.w)(s,e)}function qr(t){return 0===t?"false":"true"}function Hr(t,e,n,r,s,o=!0){const i="complex64"===n?2:1,a=e[0],l=e.length;if(0===l)return"complex64"===n?[zr(Wr(t)[0],0,n)]:"bool"===n?[qr(t[0])]:[t[0].toString()];if(1===l){if(a>20){const e=3*i;let r=Array.from(t.slice(0,e)),o=Array.from(t.slice((a-3)*i,a*i));return"complex64"===n&&(r=Wr(r),o=Wr(o)),["["+r.map(((t,e)=>zr(t,s[e],n))).join(", ")+", ..., "+o.map(((t,e)=>zr(t,s[a-3+e],n))).join(", ")+"]"]}return["["+("complex64"===n?Wr(t):Array.from(t)).map(((t,e)=>zr(t,s[e],n))).join(", ")+"]"]}const h=e.slice(1),u=r.slice(1),c=r[0]*i,d=[];if(a>20){for(let e=0;e<3;e++){const r=e*c,o=r+c;d.push(...Hr(t.slice(r,o),h,n,u,s,!1))}d.push("...");for(let e=a-3;e<a;e++){const r=e*c,o=r+c;d.push(...Hr(t.slice(r,o),h,n,u,s,e===a-1))}}else for(let e=0;e<a;e++){const r=e*c,o=r+c;d.push(...Hr(t.slice(r,o),h,n,u,s,e===a-1))}const f=2===l?",":"";d[0]="["+d[0]+f;for(let t=1;t<d.length-1;t++)d[t]=" "+d[t]+f;let g=",\n";for(let t=2;t<l;t++)g+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":g),d}function Wr(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class Gr{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=(0,r.m)(t),null!=n){const t=n.length;(0,r.a)(t===this.size,(()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||(0,r.C)(e,this.size),this.strides=(0,r.O)(t)}set(t,...e){0===e.length&&(e=[0]),(0,r.a)(e.length===this.rank,(()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`));const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const n of t){if(n<0||n>=this.shape[e]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}e++}let n=t[t.length-1];for(let e=0;e<t.length-1;++e)n+=this.strides[e]*t[e];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Vr().makeTensor(this.values,this.shape,this.dtype)}}let Vr=null,Kr=null;class Jr{constructor(t,e,n,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=(0,r.m)(t),this.strides=(0,r.O)(t),this.dataId=n,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Kr.buffer(this.shape,this.dtype,t)}bufferSync(){return Kr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return(0,r.t)(this.shape,t,"complex64"===this.dtype)}arraySync(){return(0,r.t)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Vr().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map((t=>Cr(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Vr().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Vr().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>Cr(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Vr().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Vr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Kr.print(this,t)}clone(){return this.throwIfDisposed(),Kr.clone(this)}toString(t=!1){return jr(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Kr.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Vr().makeVariable(this,t,e,n)}}Object.defineProperty(Jr,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),O("Tensor",(()=>Jr));class Zr extends Jr{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!(0,r.b)(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Vr().disposeTensor(this),this.dataId=t.dataId,Vr().incRef(this,null)}dispose(){Vr().disposeVariable(this),this.isDisposedInternal=!0}}var Qr,Xr,Yr,ts,es;Object.defineProperty(Zr,Symbol.hasInstance,{value:t=>t instanceof Jr&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Qr||(Qr={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Xr||(Xr={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Yr||(Yr={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(ts||(ts={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(es||(es={}));const ns={float32:ts,int32:Xr,bool:Yr,complex64:es};function rs(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return ns[t][e]}function ss(t){return rs(t,"int32")}function os(t,e){if(t.dtype===e.dtype)return[t,e];const n=rs(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function is(t,e){(0,r.a)(t.dtype===e.dtype,(()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`))}function as(t){const e=[];return ls(t,e,new Set),e}function ls(t,e,n){if(null==t)return;if(t instanceof Jr)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=t;for(const t in s){const r=s[t];n.has(r)||(n.add(r),ls(r,e,n))}}function hs(t){return null!=t.kernelName}class us{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class cs{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new us}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(Un(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Or(this.backendInstance),!0}setupRegisteredKernels(){Gn(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){Gn(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof o||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0)))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,Un(`Initialization of backend ${t} failed`),Un(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return Un(`Initialization of backend ${t} failed`),Un(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,s=this.readSync(e),o=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,s,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return cs.nextTensorId++}nextVariableId(){return cs.nextVariableId++}clone(t){const e=fs.runKernel(Jt,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t};return fs.runKernel(at,e,{dtype:"float32"})}})),[],{}),e}runKernel(t,e,n){if(null==this.backendName&&this.backend,null==Hn(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let s=0;n.forEach((t=>{s+="complex64"===t.dtype?3:1}));const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-e-s-o;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const s=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;let a,l;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const h=hs(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(hs(t)){const{kernelName:e,inputs:o,attrs:i}=t;null==this.backendName&&this.backend;const h=Hn(e,this.backendName);(0,r.a)(null!=h,(()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`)),a=()=>{const t=this.backend.numDataIds();l=h.kernelFunc({inputs:o,attrs:i,backend:this.backend});const r=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,r);const a=r.map((t=>{if(null!=t.rank)return t;const{dataId:e,shape:n,dtype:r}=t;return this.makeTensorFromDataId(e,n,r)}));if(s){const t=this.getTensorsForGradient(e,o,a);n=this.saveTensorsForBackwardMode(t)}return a}}else{const{forwardFunc:e}=t,r=t=>{s&&(n=t.map((t=>this.keep(this.clone(t)))))};a=()=>{const t=this.backend.numDataIds();l=this.tidy((()=>e(this.backend,r)));const n=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,t,n),n}}const{inputs:u,attrs:c}=t,d=hs(t)?null:t.backwardsFunc;let f;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(h,u,(()=>a())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),e=f.outputs):e=a()})),s&&this.addTapeNode(h,u,e,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:h,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((t=>null!=u[t]?u[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?e:e[0]}saveTensorsForBackwardMode(t){const e=t.map((t=>this.keep(this.clone(t))));return e}getTensorsForGradient(t,e,n){const s=Wn(t);if(null!=s){const t=s.inputsToSave||[],o=s.outputsToSave||[];let i;s.saveAllInputs?((0,r.a)(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),i=Object.keys(e).map((t=>e[t]))):i=t.map((t=>e[t]));const a=n.filter(((t,e)=>o[e]));return i.concat(a)}return[]}makeTensor(t,e,n,s){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",s=s||this.backend;let o=t;"string"===n&&(0,r.I)(t[0])&&(o=t.map((t=>Pr(t))));const i=s.write(o,e,n),a=new Jr(e,n,i,this.nextTensorId());if(this.trackTensor(a,s),"string"===n){const t=this.state.tensorInfo.get(i),e=(0,r.H)(o);this.state.numBytes+=e-t.bytes,t.bytes=e}return a}makeTensorFromDataId(t,e,n,r){const s=new Jr(e,n=n||"float32",t,this.nextTensorId());return this.trackTensor(s,r),s}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const s=new Zr(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*(0,r.G)(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Zr||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*(0,r.G)(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,s,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:o},l=Wn(t);null!=l&&(s=l.gradFunc),null!=s&&(a.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],s=(0,r.Q)(t.size,t.dtype);return this.makeTensor(s,t.shape,t.dtype)}return t})),s(t.length>1?t:t[0],o,i))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=as(t),n=new Set(e.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n,s=!1){if((0,r.a)(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const o=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));(0,r.a)(o instanceof Jr,(()=>"The result y returned by f() must be a tensor."));const i=function(t,e,n){const r={},s={};for(let t=0;t<e.length;t++)r[e[t].id]=!0;for(let n=0;n<t.length;n++){const o=t[n],i=o.inputs;for(const t in i){const n=i[t];let a=!1;for(let t=0;t<e.length;t++)if(r[n.id]){o.outputs.forEach((t=>r[t.id]=!0)),a=!0,s[o.id]=!0;break}if(a)break}}const o={};o[n.id]=!0;const i={};for(let e=t.length-1;e>=0;e--){const n=t[e],r=n.inputs;for(let t=0;t<n.outputs.length;t++)if(o[n.outputs[t].id]){for(const t in r)o[r[t].id]=!0,i[n.id]=!0;break}}const a=[];for(let e=0;e<t.length;e++){const n=t[e];if(s[n.id]&&i[n.id]){const t={};for(const e in n.inputs){const s=n.inputs[e];r[s.id]&&(t[e]=s)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,a.push(e)}}return a}(this.state.activeTape,e,o);if(!s&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[o.id]=null==n?function(t){const e=(0,r.P)((0,r.m)(t),"float32");return fs.makeTensor(e,t,"float32")}(o.shape):n,function(t,e,n,s){for(let o=e.length-1;o>=0;o--){const i=e[o],a=[];if(i.outputs.forEach((e=>{const n=t[e.id];null!=n?a.push(n):a.push(null)})),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const l=i.gradient(a);for(const e in i.inputs){if(!(e in l))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(l)}.`);const o=n((()=>l[e]()));if("float32"!==o.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${o.dtype}'`);const a=i.inputs[e];if(!(0,r.b)(o.shape,a.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${e}' has shape '${o.shape}', which does not match the shape of the input '${a.shape}'`);if(null==t[a.id])t[a.id]=o;else{const e=t[a.id];t[a.id]=s(e,o),e.dispose()}}}}(t,i,(t=>this.tidy(t)),gs);const s=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:o,grads:s}}))}customGrad(t){return(0,r.a)((0,r.M)(t),(()=>"The f passed in customGrad(f) must be a function.")),(...e)=>{let n;(0,r.a)(e.every((t=>t instanceof Jr)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const s={};return e.forEach(((t,e)=>{s[e]=t})),this.runKernelFunc({forwardFunc:(s,o)=>(n=t(...e,o),(0,r.a)(n.value instanceof Jr,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),(0,r.a)((0,r.M)(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(t,s)=>{const o=n.gradFunc(t,s),i=Array.isArray(o)?o:[o];(0,r.a)(i.length===e.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),(0,r.a)(i.every((t=>t instanceof Jr)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const a={};return i.forEach(((t,e)=>{a[e]=()=>t})),a},inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=Lr(),n=await this.backend.time(t);return n.wallMs=Lr()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new us;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function ds(){const t=C();if(null==t._tfengine){const e=new a(t);t._tfengine=new cs(e)}var e;return e=t._tfengine.ENV,u=e,Vr=()=>t._tfengine,t._tfengine}cs.nextTensorId=0,cs.nextVariableId=0;const fs=ds();function gs(t,e){const n={a:t,b:e};return fs.runKernel(z,n)}function ps(t){if(t||"undefined"!=typeof navigator&&null!=navigator){if(t||(t=navigator),"ReactNative"===t.product)return!0;const e=t.userAgent||t.vendor||("undefined"!=typeof window?window.opera:"");if(!e){const e=t;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function ms(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const ys=h();function ws(t,e){let n=t;if((0,r.F)(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const s=[];for(;Array.isArray(n)||(0,r.F)(n)&&"string"!==e;)s.push(n.length),n=n[0];return Array.isArray(t)&&h().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&bs(t,s,[]),s}function bs(t,e,n){if(n=n||[],!Array.isArray(t)&&!(0,r.F)(t))return void(0,r.a)(0===e.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));(0,r.a)(e.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),(0,r.a)(t.length===e[0],(()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const s=e.slice(1);for(let e=0;e<t.length;++e)bs(t[e],s,n.concat(e))}function ks(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function vs(t,e,n,s="numeric"){if(t instanceof Jr)return ks(s,t.dtype,e,n),t;let o=(0,r.L)(t);if("string"!==o&&["bool","int32","float32"].indexOf(s)>=0&&(o=s),ks(s,o,e,n),null==t||!(0,r.F)(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const i=ws(t,o);(0,r.F)(t)||Array.isArray(t)||(t=[t]);const a="string"!==o?Nr(t,o):(0,r.f)(t,[],!0);return fs.makeTensor(a,i,o)}function Es(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,s)=>vs(t,`${e}[${s}]`,n,r)))}function Is(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const o=(...t)=>{fs.startScope(n);try{const e=s(...t);return(0,r.i)(e)&&console.error("Cannot return a Promise inside of tidy."),fs.endScope(e),e}catch(t){throw fs.endScope(null),t}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}ys.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),ys.registerFlag("IS_BROWSER",(()=>ms())),ys.registerFlag("IS_NODE",(()=>void 0!==L&&void 0!==L.versions&&void 0!==L.versions.node)),ys.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),ys.registerFlag("PROD",(()=>!1)),ys.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>ys.getBool("DEBUG"))),ys.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),ys.registerFlag("IS_TEST",(()=>!1)),ys.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),ys.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1));const Ss=Is({complex_:function(t,e){const n=vs(t,"real","complex"),s=vs(e,"imag","complex");(0,r.k)(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const o={real:n,imag:s};return fs.runKernel(ut,o)}});function xs(t,e,n,s){if(null==s&&(s=(0,r.L)(t)),"complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!(0,r.F)(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){(0,r.S)(e);const t=(0,r.m)(e),s=(0,r.m)(n);(0,r.a)(t===s,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${s}`));for(let t=0;t<n.length;++t){const s=n[t],o=t!==n.length-1||s!==(0,r.m)(e.slice(t));(0,r.a)(n[t]===e[t]||!o,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return(0,r.F)(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==s?Nr(t,s):(0,r.f)(t,[],!0),fs.makeTensor(t,e,s)}function Ts(t,e,n){return xs(t,e,ws(t,n),n)}const Bs={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function As(t,e){const n=[],r=[],s=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let o=0;o<s.length;++o){const i=s[o],a=Array.isArray(t)?t[o].tensor:t[i];if("float32"!==a.dtype&&"int32"!==a.dtype&&"bool"!==a.dtype&&"string"!==a.dtype&&"complex64"!==a.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${a.dtype}`);const l={name:i,shape:a.shape,dtype:a.dtype};if("string"===a.dtype){const t=new Promise((async t=>{const e=await a.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+4*e.length,r=new Uint8Array(n);let s=0;for(let t=0;t<e.length;t++){const n=e[t],o=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(o,s),s+=4,r.set(n,s),s+=n.length}t(r)}));r.push(t)}else r.push(a.data());null!=e&&(l.group=e),n.push(l)}return{data:Ms(await Promise.all(r)),specs:n}}function $s(t,e){const n={};let s,o=0;for(const i of e){const e=i.name,a=i.dtype,l=i.shape,h=(0,r.m)(l);let u;if("quantization"in i){const n=i.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${i.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${i.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${a}.`)}const r=Bs[n.dtype],l=t.slice(o,o+h*r),c="uint8"===n.dtype?new Uint8Array(l):new Uint16Array(l);if("float32"===a)if("uint8"===n.dtype||"uint16"===n.dtype){u=new Float32Array(c.length);for(let t=0;t<c.length;t++){const e=c[t];u[t]=e*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===s&&(s=Os()),u=s(c)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${e}': ${a}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);u=new Int32Array(c.length);for(let t=0;t<c.length;t++){const e=c[t];u[t]=Math.round(e*n.scale+n.min)}}o+=h*r}else if("string"===a){const e=(0,r.m)(i.shape);u=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(o,o+4))[0];o+=4;const n=new Uint8Array(t.slice(o,o+e));u.push(n),o+=e}}else{const r=Bs[a],s=t.slice(o,o+h*r);if("float32"===a)u=new Float32Array(s);else if("int32"===a)u=new Int32Array(s);else if("bool"===a)u=new Uint8Array(s);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${e}': ${a}`);{u=new Float32Array(s);const t=new Float32Array(u.length/2),r=new Float32Array(u.length/2);for(let e=0;e<t.length;e++)t[e]=u[2*e],r[e]=u[2*e+1];const o=Ts(t,l,"float32"),i=Ts(r,l,"float32");n[e]=Ss(o,i),o.dispose(),i.dispose()}}o+=h*r}"complex64"!==a&&(n[e]=Ts(u,l,a))}return n}function Ms(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)}));const r=new Uint8Array(e);let s=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),s),s+=t.byteLength})),r.buffer}const Ds="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Fs(t){return Ds?Buffer.byteLength(t):new Blob([t]).size}function Rs(t){if(1===t.length)return t[0];let e=0;t.forEach((t=>{e+=t.byteLength}));const n=new Uint8Array(e);let r=0;return t.forEach((t=>{n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function Ns(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const e=t.split("/");return e[e.length-1]}function Ls(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}async function Ps(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),null!=t.weightsManifest){const[r,s]=await e(t.weightsManifest);n.weightSpecs=r,n.weightData=s}return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),n}function Cs(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:Fs(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:Fs(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function Os(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let s=0;s<r.length;s++){const i=r[s],a=t[n[i>>10]+(1023&i)]+e[i>>10];o[s]=a}return new Float32Array(s)}}class _s{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==_s.instance&&(_s.instance=new _s),_s.instance}static registerSaveRouter(t){_s.getInstance().saveRouters.push(t)}static registerLoadRouter(t){_s.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return _s.getHandlers(t,"save")}static getLoadHandlers(t,e){return _s.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?_s.getInstance().loadRouters:_s.getInstance().saveRouters).forEach((e=>{const s=e(t,n);null!==s&&r.push(s)})),r}}const Us=t=>_s.registerSaveRouter(t),js=t=>_s.registerLoadRouter(t),zs=t=>_s.getSaveHandlers(t),qs=(t,e)=>_s.getLoadHandlers(t,e),Hs="tensorflowjs",Ws="models_store",Gs="model_info_store";function Vs(){if(!h().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Ks(t){const e=t.result;e.createObjectStore(Ws,{keyPath:"modelPath"}),e.createObjectStore(Gs,{keyPath:"modelPath"})}class Js{constructor(t){if(this.indexedDB=Vs(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(Hs,1);r.onupgradeneeded=()=>Ks(r),r.onsuccess=()=>{const s=r.result;if(null==e){const e=s.transaction(Ws,"readonly"),r=e.objectStore(Ws).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(r.result.modelArtifacts)},r.onerror=t=>(s.close(),n(r.error)),e.oncomplete=()=>s.close()}else{const r=Cs(e),o=s.transaction(Gs,"readwrite");let i=o.objectStore(Gs);const a=i.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;a.onsuccess=()=>{l=s.transaction(Ws,"readwrite");const a=l.objectStore(Ws).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});a.onsuccess=()=>t({modelArtifactsInfo:r}),a.onerror=t=>{i=o.objectStore(Gs);const e=i.delete(this.modelPath);e.onsuccess=()=>(s.close(),n(a.error)),e.onerror=t=>(s.close(),n(a.error))}},a.onerror=t=>(s.close(),n(a.error)),o.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}}},r.onerror=t=>n(r.error)}))}}Js.URL_SCHEME="indexeddb://";const Zs=t=>{return h().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Js.URL_SCHEME)?(e=t.slice(Js.URL_SCHEME.length),new Js(e)):null;var e};_s.registerSaveRouter(Zs),_s.registerLoadRouter(Zs);class Qs{constructor(){this.indexedDB=Vs()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(Hs,1);n.onupgradeneeded=()=>Ks(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(Gs,"readonly"),o=s.objectStore(Gs).getAll();o.onsuccess=()=>{const e={};for(const t of o.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},o.onerror=t=>(r.close(),e(o.error)),s.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(Js.URL_SCHEME)?e.slice(Js.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(Hs,1);r.onupgradeneeded=()=>Ks(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(Gs,"readwrite"),i=o.objectStore(Gs),a=i.get(t);let l;a.onsuccess=()=>{if(null==a.result)return s.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=i.delete(t),o=()=>{l=s.transaction(Ws,"readwrite");const r=l.objectStore(Ws).delete(t);r.onsuccess=()=>e(a.result.modelArtifactsInfo),r.onerror=t=>n(a.error)};r.onsuccess=o,r.onerror=t=>(o(),s.close(),n(a.error))}},a.onerror=t=>(s.close(),n(a.error)),o.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=t=>n(r.error)}))}}const Xs="/",Ys="tensorflowjs_models",to="info",eo="model_topology",no="weight_specs",ro="weight_data",so="model_metadata";function oo(t){return{info:[Ys,t,to].join(Xs),topology:[Ys,t,eo].join(Xs),weightSpecs:[Ys,t,no].join(Xs),weightData:[Ys,t,ro].join(Xs),modelMetadata:[Ys,t,so].join(Xs)}}function io(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function ao(t){const e=t.split(Xs);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Xs)}class lo{constructor(t){if(!h().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=oo(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=Cs(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(Ds)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let t=0,r=e.length;t<r;t++)n+=String.fromCharCode(e[t]);return btoa(n)}(t.weightData));const s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch(t){throw io(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const t=JSON.parse(s);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(null==o)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(Ds){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)n.set([e.charCodeAt(t)],t);return n.buffer}(o),e}}lo.URL_SCHEME="localstorage://";const ho=t=>{return h().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(lo.URL_SCHEME)?(e=t.slice(lo.URL_SCHEME.length),new lo(e)):null;var e};_s.registerSaveRouter(ho),_s.registerLoadRouter(ho);class uo{constructor(){(0,r.a)(h().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),(0,r.a)("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=Ys+Xs,n=Xs+to;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);s.startsWith(e)&&s.endsWith(n)&&(t[ao(s)]=JSON.parse(this.LS.getItem(s)))}return t}async removeModel(t){var e;const n=oo(t=(e=t).startsWith(lo.URL_SCHEME)?e.slice(lo.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return io(n),r}}const co="://";class fo{constructor(){this.managers={}}static getInstance(){return null==fo.instance&&(fo.instance=new fo),fo.instance}static registerManager(t,e){(0,r.a)(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(co)&&(t=t.slice(0,t.indexOf(co))),(0,r.a)(t.length>0,(()=>"scheme must not be an empty string."));const n=fo.getInstance();(0,r.a)(null==n.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function go(t){if(-1===t.indexOf(co))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${fo.getSchemes().join(",")}`);return{scheme:t.split(co)[0],path:t.split(co)[1]}}async function po(t,e,n=!1){(0,r.a)(t!==e,(()=>`Old path and new path are the same: '${t}'`));const s=_s.getLoadHandlers(t);(0,r.a)(s.length>0,(()=>`Copying failed because no load handler is found for source URL ${t}.`)),(0,r.a)(s.length<2,(()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${t}.`));const o=s[0],i=_s.getSaveHandlers(e);(0,r.a)(i.length>0,(()=>`Copying failed because no save handler is found for destination URL ${e}.`)),(0,r.a)(i.length<2,(()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`));const a=i[0],l=go(t).scheme,h=go(t).path,u=l===go(t).scheme,c=await o.load();n&&u&&await fo.getManager(l).removeModel(h);const d=await a.save(c);return n&&!u&&await fo.getManager(l).removeModel(h),d.modelArtifactsInfo}async function mo(){const t=fo.getSchemes(),e={};for(const n of t){const t=await fo.getManager(n).listModels();for(const r in t)e[n+co+r]=t[r]}return e}async function yo(t){const e=go(t);return fo.getManager(e.scheme).removeModel(e.path)}async function wo(t,e){return po(t,e,!1)}async function bo(t,e){return po(t,e,!0)}class ko{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(h().get("IS_BROWSER")){h().setPlatform("browser",new ko);try{fo.registerManager(lo.URL_SCHEME,new uo)}catch(t){}try{fo.registerManager(Js.URL_SCHEME,new Qs)}catch(t){}}let vo;function Eo(t,e="float32",n){return e=e||"float32",(0,r.S)(t),new Gr(t,e,n)}h().get("IS_NODE")&&h().setPlatform("node",new class{constructor(){this.util=n(1323),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=h().global.fetch?h().global.fetch(t,e):(null==vo&&(vo=n(759)),vo(t,e))}now(){const t=L.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const Io=Is({cast_:function(t,e){const n=vs(t,"x","cast");if(!(0,r.D)(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const s={x:n},o={dtype:e};return fs.runKernel(at,s,o)}}),So=Is({clone_:function(t){const e={x:vs(t,"x","clone","string_or_numeric")};return fs.runKernel(Jt,e)}});function xo(t,e,n,s){!function(t){(0,r.a)(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){(0,r.a)(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`)),(0,r.a)(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`)),(0,r.a)(e>=t,(()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`))}(n=null==n?0:n,s=null==s?1:s);let o=0;return Promise.all(t.map((r=>(r.then((r=>{const i=n+ ++o/t.length*(s-n);return e(i),r})),r))))}async function To(t,e){null==e&&(e={});const n=null==e.fetchFunc?h().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),s=(null==e.onProgress?await Promise.all(r):await xo(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(s):await xo(s,e.onProgress,.5,1)}async function Bo(t,e="",n,r){return Ao((t=>To(t,{requestInit:r})))(t,e,n)}function Ao(t){return async(e,n="",s)=>{const o=e.map((()=>!1)),i={},a=null!=s?s.map((()=>!1)):[],l=[];if(e.forEach(((t,e)=>{let n=0;t.weights.forEach((t=>{const h="quantization"in t?t.quantization.dtype:t.dtype,u=Bs[h]*(0,r.m)(t.shape),c=()=>{o[e]=!0,null==i[e]&&(i[e]=[]),i[e].push({manifestEntry:t,groupOffset:n,sizeBytes:u})};null!=s?s.forEach(((e,n)=>{e===t.name&&(c(),a[n]=!0)})):c(),l.push(t.name),n+=u}))})),!a.every((t=>t))){const t=s.filter(((t,e)=>!a[e]));throw new Error(`Could not find weights in manifest with names: ${t.join(", ")}. \nManifest JSON has weights with names: ${l.join(", ")}.`)}const h=o.reduce(((t,e,n)=>(e&&t.push(n),t)),[]),u=[];h.forEach((t=>{e[t].paths.forEach((t=>{const e=n+(n.endsWith("/")?"":"/")+t;u.push(e)}))}));const c=await t(u),d={};let f=0;return h.forEach((t=>{const n=e[t].paths.length;let r=0;for(let t=0;t<n;t++)r+=c[f+t].byteLength;const s=new ArrayBuffer(r),o=new Uint8Array(s);let a=0;for(let t=0;t<n;t++){const e=new Uint8Array(c[f+t]);o.set(e,a),a+=e.byteLength}i[t].forEach((t=>{const e=$s(s.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(const t in e)d[t]=e[t]})),f+=n})),d}}ds(),Kr={buffer:Eo,cast:Io,clone:So,print:function(t,e=!1){console.log(t.toString(e))}};class $o{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?((0,r.a)("function"==typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=h().platform.fetch,(0,r.a)(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&(0,r.a)(2===t.length,(()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`)),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=Ls(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:Cs(t),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Ps(e,(t=>this.loadWeights(t)))}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(e),s=this.weightPathPrefix||n,o=[];for(const e of t)o.push(...e.weights);const i=[],a=[];for(const e of t)for(const t of e.paths)null!=this.weightUrlConverter?a.push(this.weightUrlConverter(t)):i.push(s+t+r);return this.weightUrlConverter&&i.push(...await Promise.all(a)),[o,Rs(await To(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function Mo(t){return null!=t.match($o.URL_SCHEME_REGEX)}$o.URL_SCHEME_REGEX=/^https?:\/\//;const Do=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>Mo(t))):Mo(t),n)return Fo(t,e)}return null};function Fo(t,e){return new $o(t,e)}function Ro(t,e){return Fo(t,e)}function No(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const o=n-1-s,i=t[o]||1;(e[e.length-1-s]||1)>1&&1===i&&r.unshift(o)}return r}function Lo(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],o=e.length-r-1,i=e[o];(null==s||1===s&&i>1)&&n.unshift(o)}return n}function Po(t,e){const n=[],r=Math.max(t.length,e.length);for(let s=0;s<r;s++){let r=t[t.length-s-1];null==r&&(r=1);let o=e[e.length-s-1];if(null==o&&(o=1),1===r)n.unshift(o);else if(1===o)n.unshift(r);else{if(r!==o)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(r)}}return n}function Co(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(o+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(o+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(o+" update.rank != "+(s+t.length-r));for(let t=0;t<s;++t)if(n.shape[t]!==e.shape[t])throw new Error(o+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-s;++e)if(n.shape[e+s]!==t[e+r])throw new Error(o+` updates.shape[${e+s}] (${n.shape[e+s]}) != shape[${e+s}] (${t[e+s]})`)}function Oo(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}Co(n,e,t)}function _o(t,e,n){const s=e.shape.length,o=s>1?e.shape[s-1]:1,i=n.length;let a=1;for(let t=o;t<i;++t)a*=n[t];const l=o<1?1:o;return{sliceRank:o,numUpdates:(0,r.m)(e.shape)/l,sliceSize:a,strides:[...(0,r.O)(n.slice(0,o)),1],outputSize:(0,r.m)(n)}}function Uo(){return fs}function jo(t,e){return fs.tidy(t,e)}function zo(t){as(t).forEach((t=>t.dispose()))}function qo(t){return fs.keep(t)}function Ho(t){return fs.setBackend(t)}function Wo(t,e,n=1){return fs.registerBackend(t,e,n)}_s.registerSaveRouter(Do),_s.registerLoadRouter(Do);const Go=Is({mul_:function(t,e){let n=vs(t,"a","mul"),r=vs(e,"b","mul");[n,r]=os(n,r);const s={a:n,b:r};return fs.runKernel(xe,s)}});function Vo(t,e,n,r,s="NHWC",o){return Zo(t,[...e,t[3]],n,o,r,null,null,oi(s))}function Ko(t,e,n,r,s,o,i="channelsLast"){const[a,l]=Yo(e);let h;if("channelsLast"===i)h=[a,l,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);h=[a,l,t[1],t[1]]}return Zo(t,h,n,r,s,o,!1,i)}function Jo(t,e,n,r,s,o,i="NDHWC"){const[a,l,h]=ti(e);let u,c;if("NDHWC"===i)c="channelsLast",u=[a,l,h,t[4],t[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);c="channelsFirst",u=[a,l,h,t[1],t[1]]}return Qo(t,u,n,r,s,!1,c,o)}function Zo(t,e,n,r,s,o,i=!1,a="channelsLast"){let[l,h,u,c]=[-1,-1,-1,-1];if("channelsLast"===a)[l,h,u,c]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,c,h,u]=t}const[d,f,,g]=e,[p,m]=Yo(n),[y,w]=Yo(r),b=ei(d,y),k=ei(f,w),{padInfo:v,outHeight:E,outWidth:I}=function(t,e,n,r,s,o,i,a,l){let h,u,c;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,r,s){null==r&&(r=Xo(t,e,n));const o=t[1];return[ni((t[0]-e+2*r)/n+1,s),ni((o-e+2*r)/n+1,s)]}([e,n],o,r,t,a);u=s[0],c=s[1]}else if("same"===t){u=Math.ceil(e/r),c=Math.ceil(n/s);const t=Math.max(0,(u-1)*r+o-e),a=Math.max(0,(c-1)*s+i-n),l=Math.floor(t/2),d=t-l,f=Math.floor(a/2);h={top:l,bottom:d,left:f,right:a-f,type:"SAME"}}else if("valid"===t)h={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-o+1)/r),c=Math.ceil((n-i+1)/s);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===l?t[1][0]:t[2][0],f="channelsLast"===l?t[1][1]:t[2][1],g="channelsLast"===l?t[2][0]:t[3][0],p="channelsLast"===l?t[2][1]:t[3][1];h={top:d,bottom:f,left:g,right:p,type:0===d&&0===f&&0===g&&0===p?"VALID":"EXPLICIT"},u=ni((e-o+d+f)/r+1,a),c=ni((n-i+g+p)/s+1,a)}}return{padInfo:h,outHeight:u,outWidth:c}}(s,h,u,p,m,b,k,o,a),S=i?g*c:g;let x;return"channelsFirst"===a?x=[l,S,E,I]:"channelsLast"===a&&(x=[l,E,I,S]),{batchSize:l,dataFormat:a,inHeight:h,inWidth:u,inChannels:c,outHeight:E,outWidth:I,outChannels:S,padInfo:v,strideHeight:p,strideWidth:m,filterHeight:d,filterWidth:f,effectiveFilterHeight:b,effectiveFilterWidth:k,dilationHeight:y,dilationWidth:w,inShape:t,outShape:x,filterShape:e}}function Qo(t,e,n,r,s,o=!1,i="channelsLast",a){let[l,h,u,c,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,h,u,c,d]=t;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,d,h,u,c]=t}const[f,g,p,,m]=e,[y,w,b]=ti(n),[k,v,E]=ti(r),I=ei(f,k),S=ei(g,v),x=ei(p,E),{padInfo:T,outDepth:B,outHeight:A,outWidth:$}=function(t,e,n,r,s,o,i,a,l,h,u){let c,d,f,g;if("number"==typeof t){c={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const o=function(t,e,n,r,s,o){null==s&&(s=Xo(t,e,r));const i=t[1],a=t[2];return[ni((t[0]-e+2*s)/r+1,o),ni((i-e+2*s)/r+1,o),ni((a-e+2*s)/r+1,o),1]}([e,n,r,1],a,0,s,t,u);d=o[0],f=o[1],g=o[2]}else if("same"===t){d=Math.ceil(e/s),f=Math.ceil(n/o),g=Math.ceil(r/i);const t=(d-1)*s+a-e,u=(f-1)*o+l-n,p=(g-1)*i+h-r,m=Math.floor(t/2),y=t-m,w=Math.floor(u/2),b=u-w,k=Math.floor(p/2);c={top:w,bottom:b,left:k,right:p-k,front:m,back:y,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);c={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-a+1)/s),f=Math.ceil((n-l+1)/o),g=Math.ceil((r-h+1)/i)}return{padInfo:c,outDepth:d,outHeight:f,outWidth:g}}(s,h,u,c,y,w,b,I,S,x,a),M=o?m*d:m;let D;return"channelsFirst"===i?D=[l,M,B,A,$]:"channelsLast"===i&&(D=[l,B,A,$,M]),{batchSize:l,dataFormat:i,inDepth:h,inHeight:u,inWidth:c,inChannels:d,outDepth:B,outHeight:A,outWidth:$,outChannels:M,padInfo:T,strideDepth:y,strideHeight:w,strideWidth:b,filterDepth:f,filterHeight:g,filterWidth:p,effectiveFilterDepth:I,effectiveFilterHeight:S,effectiveFilterWidth:x,dilationDepth:k,dilationHeight:v,dilationWidth:E,inShape:t,outShape:D,filterShape:e}}function Xo(t,e,n,r=1){const s=ei(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function Yo(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function ti(t){return"number"==typeof t?[t,t,t]:t}function ei(t,e){return e<=1?t:t+(t-1)*(e-1)}function ni(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function ri(t){const[e,n,r]=Yo(t);return 1===e&&1===n&&1===r}function si(t,e){return ri(t)||ri(e)}function oi(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function ii(t,e,n){if(null!=n){if("string"==typeof e)throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if("number"==typeof e)(0,r.a)((0,r.p)(e),(()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`));else{if("object"!=typeof e)throw Error(`Error in ${t}: Unknown padding parameter: ${e}`);e.forEach((e=>{e.forEach((e=>{(0,r.a)((0,r.p)(e),(()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`))}))}))}}}const ai=Is({reshape_:function(t,e){const n={x:vs(t,"x","reshape","string_or_numeric")},r={shape:e};return fs.runKernel(ze,n,r)}}),li=Is({sigmoid_:function(t){const e={x:vs(t,"x","sigmoid","float32")};return fs.runKernel(sn,e)}}),hi=Is({elu_:function(t){const e={x:vs(t,"x","elu","float32")};return fs.runKernel(Ft,e)}}),ui=Is({leakyRelu_:function(t,e=.2){const n={x:vs(t,"x","leakyRelu")},r={alpha:e};return fs.runKernel(ee,n,r)}}),ci=Is({sum_:function(t,e=null,n=!1){let r=vs(t,"x","sum");"bool"===r.dtype&&(r=Io(r,"int32"));const s={x:r},o={axis:e,keepDims:n};return fs.runKernel(ln,s,o)}});function di(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function fi(t,e,n){const r=t.length+e.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)-1===n.indexOf(a)?s.push(t[o++]):s.push(e[i++]);return s}function gi(t,e){const n=[],r=t.length;for(let s=0;s<r;s++)-1===e.indexOf(s)&&n.push(t[s]);return[n,e.map((e=>t[e]))]}function pi(t,e){return fi(t,e.map((t=>1)),e)}function mi(t,e,n){(0,r.a)(di(e,n),(()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`))}function yi(t,e){if(di(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function wi(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function bi(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}function ki(t,e="float32"){if("complex64"===e){const e=ki(t,"float32"),n=ki(t,"float32");return Ss(e,n)}const n=(0,r.Q)((0,r.m)(t),e);return fs.makeTensor(n,t,e)}const vi=Is({prelu_:function(t,e){const n={x:vs(t,"x","prelu"),alpha:vs(e,"alpha","prelu")};return fs.runKernel(Pe,n)}}),Ei=Is({relu_:function(t){const e={x:vs(t,"x","relu")};return fs.runKernel(je,e)}}),Ii=Is({relu6_:function(t){const e={x:vs(t,"x","relu6")};return fs.runKernel(Ve,e)}});function Si(t,e){if(((0,r.F)(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&(0,r.F)(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return xs(t,[],[],e)}const xi=Is({step_:function(t,e=0){const n={x:vs(t,"x","step")},r={alpha:e};return fs.runKernel(Nn,n,r)}});function Ti(t,e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(t);const r=Eo(t,"int32"),s=Eo([n.length,t.length],"int32");for(let e=0;e<n.length;e++){const o=r.indexToLoc(n[e]),i=e*t.length;s.values.set(o,i)}return s.toTensor()}function Bi(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return Go(t,xi(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Ai(t,e){let n=e;const r=Lo(t.shape,e.shape);return r.length>0&&(n=ci(n,r)),ai(n,t.shape)}function $i(t,e,n,r){if("linear"===e)return t;if("relu"===e)return Ei(t);if("elu"===e)return hi(t);if("relu6"===e)return Ii(t);if("prelu"===e)return vi(t,n);if("leakyrelu"===e)return ui(t,r);if("sigmoid"===e)return li(t);throw new Error(`Unknown fused activation ${e}.`)}const Mi=(t,e)=>!(t>0)||"linear"===e;function Di(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,s=t.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=n(e,t[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}(t,e,n||Fi)}(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function Fi(t,e){return t>e?1:t<e?-1:0}function Ri(t,e,n,r,s){return Pi(t,e,n,r,s,0)}function Ni(t,e,n,r,s,o){return Pi(t,e,n,r,s,0,!1,o,!0)}function Li(t,e,n,r,s,o){return Pi(t,e,n,r,s,o,!0)}function Pi(t,e,n,r,s,o,i=!1,a=!1,l=!1){const h=[];for(let t=0;t<e.length;t++)e[t]>s&&h.push({score:e[t],boxIndex:t,suppressBeginIndex:0});h.sort(_i);const u=o>0?-.5/o:0,c=[],d=[];for(;c.length<n&&h.length>0;){const e=h.pop(),{score:n,boxIndex:o,suppressBeginIndex:i}=e;if(n<s)break;let a=!1;for(let n=c.length-1;n>=i;--n){const i=Ci(t,o,c[n]);if(i>=r){a=!0;break}if(e.score=e.score*Oi(r,u,i),e.score<=s)break}e.suppressBeginIndex=c.length,a||(e.score===n?(c.push(o),d.push(e.score)):e.score>s&&Di(h,e,_i))}const f=c.length,g=n-f;a&&g>0&&(c.push(...new Array(g).fill(0)),d.push(...new Array(g).fill(0)));const p={selectedIndices:c};return i&&(p.selectedScores=d),l&&(p.validOutputs=f),p}function Ci(t,e,n){const r=t.subarray(4*e,4*e+4),s=t.subarray(4*n,4*n+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),h=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),c=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),f=(a-o)*(l-i),g=(c-h)*(d-u);if(f<=0||g<=0)return 0;const p=Math.max(o,h),m=Math.max(i,u),y=Math.min(a,c),w=Math.min(l,d),b=Math.max(y-p,0)*Math.max(w-m,0);return b/(f+g-b)}function Oi(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function _i(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}}}]);