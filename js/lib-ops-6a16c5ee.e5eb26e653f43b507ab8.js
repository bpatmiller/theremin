/*! For license information please see lib-ops-6a16c5ee.e5eb26e653f43b507ab8.js.LICENSE.txt */
"use strict";(self.webpackChunktheremin=self.webpackChunktheremin||[]).push([[202],{5073:(e,n,t)=>{t.d(n,{$:()=>D,A:()=>dn,B:()=>fn,C:()=>$e,D:()=>xe,E:()=>ve,F:()=>ke,G:()=>ce,H:()=>ie,I:()=>se,J:()=>ae,K:()=>j,L:()=>L,M:()=>O,N:()=>K,O:()=>N,P:()=>S,Q:()=>$,R:()=>_,S:()=>g,T:()=>b,U:()=>m,V:()=>Cn,W:()=>M,X:()=>Pn,Y:()=>C,Z:()=>J,_:()=>Ae,a:()=>He,a$:()=>$t,a0:()=>We,a1:()=>Ie,a2:()=>T,a3:()=>G,a4:()=>X,a5:()=>B,a6:()=>Jn,a7:()=>Yn,a8:()=>H,a9:()=>F,aA:()=>Qn,aB:()=>h,aC:()=>re,aD:()=>u,aE:()=>Gn,aF:()=>Te,aG:()=>yn,aH:()=>Ee,aI:()=>A,aJ:()=>Y,aK:()=>W,aL:()=>U,aM:()=>y,aN:()=>v,aO:()=>k,aP:()=>E,aQ:()=>Pe,aR:()=>qe,aS:()=>Ne,aT:()=>Ln,aU:()=>Bn,aV:()=>Nn,aW:()=>ue,aX:()=>Mn,aY:()=>zn,aZ:()=>xn,a_:()=>pe,aa:()=>ne,ab:()=>qn,ac:()=>pn,ad:()=>cn,ae:()=>je,af:()=>Oe,ag:()=>l,ah:()=>Ge,ai:()=>we,aj:()=>he,ak:()=>wn,al:()=>Hn,am:()=>_t,an:()=>On,ao:()=>Rn,ap:()=>An,aq:()=>ee,ar:()=>ze,as:()=>Ce,at:()=>Me,au:()=>ge,av:()=>be,aw:()=>fe,ax:()=>de,ay:()=>Le,az:()=>Q,b:()=>Ke,b0:()=>Sn,b1:()=>Kn,b2:()=>$n,b3:()=>_n,b4:()=>St,b5:()=>R,b6:()=>q,b7:()=>Z,b8:()=>I,b9:()=>Ye,ba:()=>Ue,bb:()=>Fe,bc:()=>oe,bd:()=>p,be:()=>Wn,bf:()=>_e,bg:()=>ln,bh:()=>un,bi:()=>ye,c:()=>s,d:()=>te,e:()=>x,f:()=>f,g:()=>Ve,h:()=>w,i:()=>d,j:()=>me,k:()=>Xe,l:()=>P,m:()=>Re,n:()=>z,o:()=>Be,p:()=>Ze,q:()=>Tn,r:()=>bn,s:()=>Dn,t:()=>In,u:()=>Se,v:()=>vn,w:()=>En,x:()=>kn,y:()=>gn,z:()=>mn}),t(5389),t(3807);var r=t(9839),a=t(5912),s="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:void 0!==t.g?t.g:"undefined"!=typeof self?self:{};function o(e,n,t){return e(t={path:n,exports:{},require:function(e,n){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==n&&t.path)}},t.exports),t.exports}function i(e){return e&&Object.prototype.hasOwnProperty.call(e,"default")&&1===Object.keys(e).length?e.default:e}const u=(0,r.w)({matMul_:function(e,n,t=!1,a=!1){let s=(0,r.x)(e,"a","matMul"),o=(0,r.x)(n,"b","matMul");[s,o]=(0,r.y)(s,o);const i={a:s,b:o},u={transposeA:t,transposeB:a};return r.E.runKernel(r.B,i,u)}}),l=(0,r.w)({oneHot_:function(e,n,t=1,a=0){if(n<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${n}`);const s={indices:(0,r.x)(e,"indices","oneHot","int32")},o={depth:n,onValue:t,offValue:a};return r.E.runKernel(r.O,s,o)}}),h=(0,r.w)({transpose_:function(e,n){const t=(0,r.x)(e,"x","transpose");if(null==n&&(n=t.shape.map(((e,n)=>n)).reverse()),(0,a.a)(t.rank===n.length,(()=>`Error in transpose: rank of input ${t.rank} must match length of perm ${n}.`)),n.forEach((e=>{(0,a.a)(e>=0&&e<t.rank,(()=>"All entries in 'perm' must be between 0 and "+(t.rank-1)+` but got ${n}`))})),t.rank<=1)return t.clone();const s={x:t},o={perm:n};return r.E.runKernel(r.A,s,o)}});let c;const p=(0,r.w)({fromPixels_:function(e,n=3){if(n>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,o=!1,i=!1,u=!1,l=!1;if(e.data instanceof Uint8Array)t=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)s=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)o=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)i=!0;else if(null!=e.getContext)u=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);l=!0}if(o){const n=2;if(o&&e.readyState<n)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=(0,r.F)(r.G,r.E.backendName)){const t={pixels:e},a={numChannels:n};return r.E.runKernel(r.G,t,a)}const[h,p]=o?[e.videoWidth,e.videoHeight]:[e.width,e.height];let d,f;if(u)d=e.getContext("2d").getImageData(0,0,h,p).data;else if(s||t)d=e.data;else if(i||o||l){if(null==c)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");c=new OffscreenCanvas(1,1).getContext("2d")}else c=document.createElement("canvas").getContext("2d");c.canvas.width=h,c.canvas.height=p,c.drawImage(e,0,0,h,p),d=c.getImageData(0,0,h,p).data}if(4===n)f=new Int32Array(d);else{const e=h*p;f=new Int32Array(e*n);for(let t=0;t<e;t++)for(let e=0;e<n;++e)f[t*n+e]=d[4*t+e]}return function(e,n,t){if((0,a.l)(e),null!=n&&3!==n.length)throw new Error("tensor3d() requires shape to have three numbers");const s=(0,r.C)(e,t);if(3!==s.length&&1!==s.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===s.length&&null==n)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,r.D)(e,n,s,t)}(f,[p,h,n],"int32")}}),d=(0,r.w)({add_:function(e,n){let t=(0,r.x)(e,"a","add"),a=(0,r.x)(n,"b","add");[t,a]=(0,r.y)(t,a);const s={a:t,b:a};return r.E.runKernel(r.H,s)}}),f=(0,r.w)({floorDiv_:function(e,n){let t=(0,r.x)(e,"a","floorDiv"),a=(0,r.x)(n,"b","floorDiv");[t,a]=(0,r.y)(t,a);const s={a:t,b:a};return r.E.runKernel(r.I,s)}}),x=(0,r.w)({div_:function(e,n){let t=(0,r.x)(e,"a","div"),a=(0,r.x)(n,"b","div");if([t,a]=(0,r.y)(t,a),"int32"===t.dtype&&"int32"===a.dtype)return f(t,a);const s={a:t,b:a};return r.E.runKernel(r.R,s,{})}}),m=(0,r.w)({abs_:function(e){const n=(0,r.x)(e,"x","abs");if("complex64"===n.dtype){const e={x:n};return r.E.runKernel(r.J,e)}{const e={x:n};return r.E.runKernel(r.K,e)}}}),b=(0,r.w)({acos_:function(e){const n={x:(0,r.x)(e,"x","acos")};return r.E.runKernel(r.L,n)}}),g=(0,r.w)({acosh_:function(e){const n={x:(0,r.x)(e,"x","acosh")};return r.E.runKernel(r.M,n)}}),w=(0,r.w)({addN_:function(e){(0,a.a)(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),(0,a.a)(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const n=e.map(((e,n)=>(0,r.x)(e,`tensors${n}`,"addN"))),t=n[0];n.forEach((e=>{if(e.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),n.forEach((e=>{if(!(0,a.b)(e.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const s=n;return r.E.runKernel(r.N,s)}}),E=(0,r.w)({all_:function(e,n=null,t=!1){const a={x:(0,r.x)(e,"x","all","bool")},s={axis:n,keepDims:t};return r.E.runKernel(r.P,a,s)}}),k=(0,r.w)({any_:function(e,n=null,t=!1){const a={x:(0,r.x)(e,"x","any","bool")},s={axis:n,keepDims:t};return r.E.runKernel(r.Q,a,s)}}),v=(0,r.w)({argMax_:function(e,n=0){const t={x:(0,r.x)(e,"x","argMax")},a={axis:n};return r.E.runKernel(r.S,t,a)}}),y=(0,r.w)({argMin_:function(e,n=0){const t={x:(0,r.x)(e,"x","argMin")},a={axis:n};return r.E.runKernel(r.U,t,a)}}),_=(0,r.w)({asin_:function(e){const n={x:(0,r.x)(e,"x","asin")};return r.E.runKernel(r.V,n)}}),$=(0,r.w)({asinh_:function(e){const n={x:(0,r.x)(e,"x","asinh")};return r.E.runKernel(r.W,n)}}),S=(0,r.w)({atan_:function(e){const n={x:(0,r.x)(e,"x","atan")};return r.E.runKernel(r.X,n)}}),N=(0,r.w)({atan2_:function(e,n){let t=(0,r.x)(e,"a","atan2"),a=(0,r.x)(n,"b","atan2");[t,a]=(0,r.y)(t,a);const s={a:t,b:a};return r.E.runKernel(r.Y,s)}}),K=(0,r.w)({atanh_:function(e){const n={x:(0,r.x)(e,"x","atanh")};return r.E.runKernel(r.Z,n)}}),T=(0,r.w)({avgPool_:function(e,n,t,s,o){const i=(0,r.x)(e,"x","avgPool","float32");(0,a.a)((0,r._)(t,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '1'`));let u=i,l=!1;3===i.rank&&(l=!0,u=(0,r.h)(i,[1,i.shape[0],i.shape[1],i.shape[2]])),(0,a.a)(4===u.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${u.rank}.`)),(0,r.$)("avgPool",s,o);const h={x:u},c={filterSize:n,strides:t,pad:s,dimRoundingMode:o};let p=r.E.runKernel(r.a0,h,c);return p=(0,r.i)(p,i.dtype),l?(0,r.h)(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),D=(0,r.w)({avgPool3d_:function(e,n,t,s,o,i="NDHWC"){const u=(0,r.x)(e,"x","avgPool3d","float32");let l=u,h=!1;4===u.rank&&(h=!0,l=(0,r.h)(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),(0,a.a)(5===l.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${l.rank}.`)),(0,a.a)("NDHWC"===i,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`)),(0,r.$)("avgPool3d",s,o);const c={x:l},p={filterSize:n,strides:t,pad:s,dimRoundingMode:o,dataFormat:i};let d=r.E.runKernel(r.a1,c,p);return d=(0,r.i)(d,l.dtype),h?(0,r.h)(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),M=(0,r.w)({concat_:function(e,n=0){(0,a.a)(e.length>=1,(()=>"Pass at least one tensor to concat"));const t=(0,r.a2)(e,"tensors","concat","string_or_numeric");if("complex64"===t[0].dtype&&t.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===t.length)return(0,r.c)(t[0]);const s=t,o={axis:n};return r.E.runKernel(r.a3,s,o)}}),C=(0,r.w)({slice_:function(e,n,t){const a=(0,r.x)(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const s={x:a},o={begin:n,size:t};return r.E.runKernel(r.a4,s,o)}}),z=(0,r.w)({tanh_:function(e){const n={x:(0,r.x)(e,"x","tanh","float32")};return r.E.runKernel(r.a5,n)}}),I=(0,r.w)({batchToSpaceND_:function(e,n,t){const s=(0,r.x)(e,"x","batchToSpaceND"),o=n.reduce(((e,n)=>e*n));(0,a.a)(s.rank>=1+n.length,(()=>`input rank is ${s.rank} but should be > than blockShape.length ${n.length}`)),(0,a.a)(t.length===n.length,(()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${n.length}`)),(0,a.a)(s.shape[0]%o==0,(()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${n.join(" * ")} === ${o}`));const i={x:s},u={blockShape:n,crops:t};return r.E.runKernel(r.a6,i,u)}}),A=(0,r.w)({batchNorm_:function(e,n,t,s,o,i){null==i&&(i=.001);const u=(0,r.x)(e,"x","batchNorm"),l=(0,r.x)(n,"mean","batchNorm"),h=(0,r.x)(t,"variance","batchNorm");let c,p;null!=o&&(c=(0,r.x)(o,"scale","batchNorm")),null!=s&&(p=(0,r.x)(s,"offset","batchNorm")),(0,a.a)(l.rank===h.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),(0,a.a)(null==p||l.rank===p.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),(0,a.a)(null==c||l.rank===c.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d=function(e){let n;return n=0===e.rank||1===e.rank?(0,r.h)(e,[1,1,1,e.size]):2===e.rank?(0,r.h)(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?(0,r.h)(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,n}(u),f={x:d,scale:c,offset:p,mean:l,variance:h},x={varianceEpsilon:i},m=r.E.runKernel(r.a7,f,x);return(0,r.h)(m,u.shape)}}),W=(0,r.w)({bincount_:function(e,n,t){const s=(0,r.x)(e,"x","bincount"),o=(0,r.x)(n,"weights","bincount");(0,a.a)("int32"===s.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`)),(0,a.a)(t>=0,(()=>`size must be non-negative, but got ${t}.`)),(0,a.a)(o.size===s.size||0===o.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${o.shape}.`));const i={x:s,weights:o},u={size:t};return r.E.runKernel(r.a8,i,u)}}),R=(0,r.w)({broadcastArgs_:function(e,n){const t=(0,r.x)(e,"s0","broadcastArgs","int32"),a=(0,r.x)(n,"s1","broadcastArgs","int32");if(1!==t.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(1!==a.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);const s={s0:t,s1:a};return r.E.runKernel(r.a9,s)}}),q=(0,r.w)({broadcastTo_:function(e,n){let t=(0,r.x)(e,"broadcastTo","x");const a=t.shape;if(n.some((e=>!(e>0)||e%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${n}].`);if(n.length<t.rank)throw new Error(`broadcastTo(): shape.length=${n.length} < input.rank=${t.rank}.`);if(n.length>t.rank){const e=t.shape.slice();for(;e.length<n.length;)e.unshift(1);t=(0,r.h)(t,e)}const s=t.shape,o=Array.from(n);for(let e=n.length-1;e>=0;e--)if(s[e]===n[e])o[e]=1;else if(1!==t.shape[e])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${n}].`);if(0===o.map(((e,n)=>e>1?n:-1)).filter((e=>e>=0)).length)return(0,r.c)(t);const i={x:t},u={reps:o};return r.E.runKernel(r.aa,i,u)}}),O=(0,r.w)({ceil_:function(e){const n={x:(0,r.x)(e,"x","ceil","float32")};return r.E.runKernel(r.ab,n)}}),P=(0,r.w)({clipByValue_:function(e,n,t){const s=(0,r.x)(e,"x","clipByValue");(0,a.a)(n<=t,(()=>`Error in clip: min (${n}) must be less than or equal to max (${t}).`));const o={x:s},i={clipValueMin:n,clipValueMax:t};return r.E.runKernel(r.ac,o,i)}}),H=(0,r.w)({conv2d_:function(e,n,t,s,o="NHWC",i=[1,1],u){const l=(0,r.x)(e,"x","conv2d","float32"),h=(0,r.x)(n,"filter","conv2d","float32");let c=l,p=!1;3===l.rank&&(p=!0,c=(0,r.h)(l,[1,l.shape[0],l.shape[1],l.shape[2]])),(0,a.a)(4===c.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`)),(0,a.a)(4===h.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${h.rank}.`)),(0,r.$)("conv2d",s,u);const d="NHWC"===o?c.shape[3]:c.shape[1];(0,a.a)(d===h.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${h.shape[2]}.`)),(0,a.a)((0,r._)(t,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`));const f={x:c,filter:h},x={strides:t,pad:s,dataFormat:o,dilations:i,dimRoundingMode:u},m=r.E.runKernel(r.ad,f,x);return p?(0,r.h)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),F=(0,r.w)({conv1d_:function(e,n,t,s,o="NWC",i=1,u){const l=(0,r.x)(e,"x","conv1d"),h=(0,r.x)(n,"filter","conv1d");let c=l,p=!1;2===l.rank&&(p=!0,c=(0,r.h)(l,[1,l.shape[0],l.shape[1]])),(0,a.a)(3===c.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`)),(0,a.a)(3===h.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${h.rank}.`)),(0,r.$)("conv1d",s,u),(0,a.a)(c.shape[2]===h.shape[1],(()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${h.shape[1]}.`)),(0,a.a)((0,r._)(t,i),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`)),(0,a.a)("NWC"===o,(()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`));const d=(0,r.h)(h,[1,h.shape[0],h.shape[1],h.shape[2]]),f=(0,r.h)(c,[c.shape[0],1,c.shape[1],c.shape[2]]),x=H(f,d,[1,t],s,"NHWC",[1,i],u);return p?(0,r.h)(x,[x.shape[2],x.shape[3]]):(0,r.h)(x,[x.shape[0],x.shape[2],x.shape[3]])}}),V=(0,r.w)({conv2DBackpropInput_:function(e,n,t,s,o,i="NHWC",u){(0,a.a)(e.length===n.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${n.rank}) must match`));let l=e,h=n,c=!1;3===n.rank&&(c=!0,h=(0,r.h)(n,[1,n.shape[0],n.shape[1],n.shape[2]]),l=[1,e[0],e[1],e[2]]),(0,a.a)(4===l.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${l.length}.`)),(0,a.a)(4===h.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${h.rank}`)),(0,a.a)(4===t.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`));const p="NHWC"===i?l[3]:l[1],d="NHWC"===i?h.shape[3]:h.shape[1];(0,a.a)(p===t.shape[2],(()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${t.shape[2]}.`)),(0,a.a)(d===t.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[3]}.`)),(0,r.$)("conv2dDerInput",o,u);const f={dy:h,filter:t},x={strides:s,pad:o,dataFormat:i,dimRoundingMode:u,inputShape:l},m=r.E.runKernel(r.ae,f,x);return c?(0,r.h)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),B=(0,r.w)({conv2dTranspose_:function(e,n,t,a,s,o){const i=(0,r.x)(e,"x","conv2dTranspose"),u=(0,r.x)(n,"filter","conv2dTranspose");return V(t,i,u,a,s,"NHWC",o)}}),G=(0,r.w)({conv3d_:function(e,n,t,s,o="NDHWC",i=[1,1,1]){const u=(0,r.x)(e,"x","conv3d"),l=(0,r.x)(n,"filter","conv3d");let h=u,c=!1;4===u.rank&&(c=!0,h=(0,r.h)(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),(0,a.a)(5===h.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${h.rank}.`)),(0,a.a)(5===l.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${l.rank}.`)),(0,a.a)(h.shape[4]===l.shape[3],(()=>`Error in conv3d: depth of input (${h.shape[4]}) must match input depth for filter ${l.shape[3]}.`)),(0,a.a)((0,r._)(t,i),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`)),(0,a.a)("NDHWC"===o,(()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`));const p={x:h,filter:l},d={strides:t,pad:s,dataFormat:o,dilations:i},f=r.E.runKernel(r.af,p,d);return c?(0,r.h)(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),L=(0,r.w)({cos_:function(e){const n={x:(0,r.x)(e,"x","cos","float32")};return r.E.runKernel(r.ag,n)}}),j=(0,r.w)({cosh_:function(e){const n={x:(0,r.x)(e,"x","cosh","float32")};return r.E.runKernel(r.ah,n)}}),U=(0,r.w)({cumsum_:function(e,n=0,t=!1,a=!1){const s={x:(0,r.x)(e,"x","cumsum")},o={axis:n,exclusive:t,reverse:a};return r.E.runKernel(r.ai,s,o)}}),Y=(0,r.w)({denseBincount_:function(e,n,t,s=!1){const o=(0,r.x)(e,"x","denseBincount"),i=(0,r.x)(n,"weights","denseBincount");(0,a.a)("int32"===o.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`)),(0,a.a)(o.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`)),(0,a.a)(t>=0,(()=>`size must be non-negative, but got ${t}.`)),(0,a.a)(i.size===o.size||0===i.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${i.shape}.`));const u={x:o,weights:i},l={size:t,binaryOutput:s};return r.E.runKernel(r.aj,u,l)}}),Z=(0,r.w)({depthToSpace_:function(e,n,t="NHWC"){const s=(0,r.x)(e,"x","depthToSpace","float32"),o="NHWC"===t?s.shape[1]:s.shape[2],i="NHWC"===t?s.shape[2]:s.shape[3],u="NHWC"===t?s.shape[3]:s.shape[1];(0,a.a)(n>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${n}`)),(0,a.a)(o*n>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${n}  for depthToSpace with input shape\n    ${s.shape}`)),(0,a.a)(i*n>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${n} for depthToSpace with input shape\n        ${s.shape}`)),(0,a.a)(u%(n*n)==0,(()=>`Dimension size must be evenly divisible by ${n*n} but is ${u} for depthToSpace with input shape ${s.shape}`));const l={x:s},h={blockSize:n,dataFormat:t};return r.E.runKernel(r.ak,l,h)}}),X=(0,r.w)({depthwiseConv2d_:function(e,n,t,s,o="NHWC",i=[1,1],u){const l=(0,r.x)(e,"x","depthwiseConv2d","float32"),h=(0,r.x)(n,"filter","depthwiseConv2d","float32");let c=l,p=!1;3===l.rank&&(p=!0,c=(0,r.h)(l,[1,l.shape[0],l.shape[1],l.shape[2]])),(0,a.a)(4===c.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`)),(0,a.a)(4===h.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`)),(0,a.a)(c.shape[3]===h.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`)),(0,r.$)("depthwiseConv2d",s,u);const d={x:c,filter:h},f={strides:t,pad:s,dataFormat:o,dilations:i,dimRoundingMode:u},x=r.E.runKernel(r.al,d,f);return p?(0,r.h)(x,[x.shape[1],x.shape[2],x.shape[3]]):x}}),J=(0,r.w)({dilation2d_:function(e,n,t,s,o=[1,1],i="NHWC"){const u=(0,r.x)(e,"x","dilation2d"),l=(0,r.x)(n,"filter","dilation2d");(0,a.a)(3===u.rank||4===u.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${u.rank}.`)),(0,a.a)(3===l.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${l.rank}.`)),(0,a.a)("NHWC"===i,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`));let h=u,c=!1;3===u.rank&&(h=(0,r.h)(u,[1,u.shape[0],u.shape[1],u.shape[2]]),c=!0);const p={x:h,filter:l},d={strides:t,pad:s,dilations:o},f=r.E.runKernel(r.am,p,d);return c?(0,r.h)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Q=(0,r.w)({equal_:function(e,n){let t=(0,r.x)(e,"a","equal","string_or_numeric"),a=(0,r.x)(n,"b","equal","string_or_numeric");[t,a]=(0,r.y)(t,a),(0,r.an)(t.shape,a.shape);const s={a:t,b:a};return r.E.runKernel(r.ao,s)}}),ee=(0,r.w)({where_:function(e,n,t){const a=(0,r.x)(n,"a","where"),s=(0,r.x)(t,"b","where"),o=(0,r.x)(e,"condition","where","bool"),i=(0,r.an)((0,r.an)(o.shape,a.shape),s.shape),u={condition:q(o,i),t:q(a,i),e:q(s,i)};return r.E.runKernel(r.ap,u)}}),ne=(0,r.w)({zerosLike_:function(e){const n={x:(0,r.x)(e,"x","zerosLike")};return r.E.runKernel(r.aq,n)}}),te=(0,r.w)({divNoNan_:function(e,n){let t=(0,r.x)(e,"a","div"),a=(0,r.x)(n,"b","div");[t,a]=(0,r.y)(t,a);const s=x(t,a),o=ne(s),i=Q(a,o);return ee(i,o,s)}}),re=(0,r.w)({einsum_:function(e,...n){const t=n.map(((e,n)=>(0,r.x)(e,`tensors${n}`,"einsum"))),a={equation:e};return r.E.runKernel(r.ar,t,a)}}),ae=(0,r.w)({erf_:function(e){let n=(0,r.x)(e,"x","erf");(0,a.a)("int32"===n.dtype||"float32"===n.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===n.dtype&&(n=(0,r.i)(n,"float32"));const t={x:n};return r.E.runKernel(r.as,t)}}),se=(0,r.w)({exp_:function(e){const n={x:(0,r.x)(e,"x","exp")};return r.E.runKernel(r.at,n)}}),oe=(0,r.w)({expandDims_:function(e,n=0){const t=(0,r.x)(e,"x","expandDims","string_or_numeric");(0,a.a)(n<=t.rank,(()=>"Axis must be <= rank of the tensor"));const s={input:t},o={dim:n};return r.E.runKernel(r.au,s,o)}}),ie=(0,r.w)({expm1_:function(e){const n={x:(0,r.x)(e,"x","expm1")};return r.E.runKernel(r.av,n)}}),ue=(0,r.w)({tile_:function(e,n){const t=(0,r.x)(e,"x","tile","string_or_numeric");(0,a.a)(t.rank===n.length,(()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${n}.`));const s={x:t},o={reps:n};return r.E.runKernel(r.aa,s,o)}}),le=(0,r.w)({eye_:function(e,n,t,a="float32"){null==n&&(n=e);const s=(0,r.aw)([e,n],a),o=e<=n?e:n;for(let e=0;e<o;++e)s.set(1,e,e);const i=(0,r.h)(s.toTensor(),[e,n]);if(null==t)return i;if(1===t.length)return ue(oe(i,0),[t[0],1,1]);if(2===t.length)return ue(oe(oe(i,0),0),[t[0],t[1],1,1]);if(3===t.length)return ue(oe(oe(oe(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}});function he(e,n,t){const a={shape:e,value:n,dtype:t};return r.E.runKernel(r.ax,{},a)}const ce=(0,r.w)({floor_:function(e){const n={x:(0,r.x)(e,"x","floor","float32")};return r.E.runKernel(r.ay,n)}}),pe=(0,r.w)({gather_:function(e,n,t=0,a=0){const s={x:(0,r.x)(e,"x","gather"),indices:(0,r.x)(n,"indices","gather","int32")},o={axis:t,batchDims:a};return r.E.runKernel(r.az,s,o)}}),de=(0,r.w)({greater_:function(e,n){let t=(0,r.x)(e,"a","greater","string_or_numeric"),a=(0,r.x)(n,"b","greater","string_or_numeric");[t,a]=(0,r.y)(t,a),(0,r.an)(t.shape,a.shape);const s={a:t,b:a};return r.E.runKernel(r.aA,s)}}),fe=(0,r.w)({greaterEqual_:function(e,n){let t=(0,r.x)(e,"a","greaterEqual","string_or_numeric"),a=(0,r.x)(n,"b","greaterEqual","string_or_numeric");[t,a]=(0,r.y)(t,a),(0,r.an)(t.shape,a.shape);const s={a:t,b:a};return r.E.runKernel(r.aB,s)}}),xe=(0,r.w)({imag_:function(e){const n={input:(0,r.x)(e,"input","imag")};return r.E.runKernel(r.aC,n)}}),me=(0,r.w)({isNaN_:function(e){const n={x:(0,r.x)(e,"x","isNaN")};return r.E.runKernel(r.aD,n)}}),be=(0,r.w)({less_:function(e,n){let t=(0,r.x)(e,"a","less","string_or_numeric"),a=(0,r.x)(n,"b","less","string_or_numeric");[t,a]=(0,r.y)(t,a),(0,r.an)(t.shape,a.shape);const s={a:t,b:a};return r.E.runKernel(r.aE,s)}}),ge=(0,r.w)({lessEqual_:function(e,n){let t=(0,r.x)(e,"a","lessEqual","string_or_numeric"),a=(0,r.x)(n,"b","lessEqual","string_or_numeric");[t,a]=(0,r.y)(t,a),(0,r.an)(t.shape,a.shape);const s={a:t,b:a};return r.E.runKernel(r.aF,s)}});function we(e,n,t){if(t<=0)throw new Error("The number of values should be positive.");const a={start:e,stop:n,num:t};return r.E.runKernel(r.aG,{},a)}const Ee=(0,r.w)({localResponseNormalization_:function(e,n=5,t=1,s=1,o=.5){const i=(0,r.x)(e,"x","localResponseNormalization");(0,a.a)(4===i.rank||3===i.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`)),(0,a.a)((0,a.p)(n),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${n}.`));let u=i,l=!1;3===i.rank&&(l=!0,u=(0,r.h)(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const h={x:u},c={depthRadius:n,bias:t,alpha:s,beta:o},p=r.E.runKernel(r.aH,h,c);return l?(0,r.h)(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),ke=(0,r.w)({log_:function(e){const n={x:(0,r.x)(e,"x","log","float32")};return r.E.runKernel(r.aI,n)}}),ve=(0,r.w)({log1p_:function(e){const n={x:(0,r.x)(e,"x","log1p")};return r.E.runKernel(r.aJ,n)}});function ye(e,n){(0,a.a)((0,a.M)(e),(()=>"The f passed in variableGrads(f) must be a function")),(0,a.a)(null==n||Array.isArray(n)&&n.every((e=>e instanceof r.aK)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const t=null!=n;if(!t){n=[];for(const e in r.E.registeredVariables)n.push(r.E.registeredVariables[e])}const s=t?n.filter((e=>!e.trainable)):null,o=n.length;n=n.filter((e=>e.trainable)),(0,a.a)(n.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`));const{value:i,grads:u}=r.E.gradients(e,n,null,!0);(0,a.a)(u.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),(0,a.a)(0===i.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`));const l={};return n.forEach(((e,n)=>{null!=u[n]&&(l[e.name]=u[n])})),null!=s&&s.forEach((e=>l[e.name]=null)),{value:i,grads:l}}function _e(e){return r.E.customGrad(e)}const $e=(0,r.w)({neg_:function(e){const n={x:(0,r.x)(e,"x","neg")};return r.E.runKernel(r.aL,n)}}),Se=(0,r.w)({softplus_:function(e){const n={x:(0,r.x)(e,"x","softplus")};return r.E.runKernel(r.aM,n)}}),Ne=(0,r.w)({max_:function(e,n=null,t=!1){const a={x:(0,r.x)(e,"x","max")},s={reductionIndices:n,keepDims:t};return r.E.runKernel(r.aN,a,s)}}),Ke=(0,r.w)({sub_:function(e,n){let t=(0,r.x)(e,"a","sub"),a=(0,r.x)(n,"b","sub");[t,a]=(0,r.y)(t,a);const s={a:t,b:a};return r.E.runKernel(r.aO,s)}}),Te=(0,r.w)({logSoftmax_:function(e,n=-1){const t=(0,r.x)(e,"logits","logSoftmax");if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${n}`);const a=_e(((e,t)=>{const a=Ne(e,n,!0),s=Ke(e,a),o=Ke((0,r.i)(s,"float32"),ke((0,r.j)(se(s),n,!0)));return t([o]),{value:o,gradFunc:(e,t)=>{const[a]=t,s=se(a);return Ke(e,(0,r.m)((0,r.j)(e,n,!0),s))}}}));return a(t)}}),De=(0,r.w)({logSumExp_:function(e,n=null,t=!1){const s=(0,r.x)(e,"x","logSumExp"),o=(0,a.z)(n,s.shape),i=Ne(s,o,!0),u=Ke(s,i),l=se(u),h=(0,r.j)(l,o),c=ke(h),p=d((0,r.h)(i,c.shape),c);if(t){const e=(0,r.aP)(p.shape,o);return(0,r.h)(p,e)}return p}}),Me=(0,r.w)({logicalAnd_:function(e,n){const t=(0,r.x)(e,"a","logicalAnd","bool"),a=(0,r.x)(n,"b","logicalAnd","bool");(0,r.an)(t.shape,a.shape);const s={a:t,b:a};return r.E.runKernel(r.aQ,s)}}),Ce=(0,r.w)({logicalNot_:function(e){const n={x:(0,r.x)(e,"x","logicalNot","bool")};return r.E.runKernel(r.aR,n)}}),ze=(0,r.w)({logicalOr_:function(e,n){const t=(0,r.x)(e,"a","logicalOr","bool"),a=(0,r.x)(n,"b","logicalOr","bool");(0,r.an)(t.shape,a.shape);const s={a:t,b:a};return r.E.runKernel(r.aS,s)}}),Ie=(0,r.w)({maxPool_:function(e,n,t,s,o){const i=(0,r.x)(e,"x","maxPool");let u=i,l=!1;3===i.rank&&(l=!0,u=(0,r.h)(i,[1,i.shape[0],i.shape[1],i.shape[2]])),(0,a.a)(4===u.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${u.rank}.`)),(0,a.a)((0,r._)(t,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '1'`)),(0,r.$)("maxPool",s,o);const h={x:u},c={filterSize:n,strides:t,pad:s,dimRoundingMode:o},p=r.E.runKernel(r.aT,h,c);return l?(0,r.h)(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Ae=(0,r.w)({maxPool3d_:function(e,n=[1,1,1],t,s,o,i="NDHWC"){const u=(0,r.x)(e,"x","maxPool3d");let l=u,h=!1;4===u.rank&&(h=!0,l=(0,r.h)(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),(0,a.a)(5===l.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${l.rank}.`)),(0,a.a)("NDHWC"===i,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`)),(0,r.$)("maxPool3d",s,o);const c={x:l},p={filterSize:n,strides:t,pad:s,dimRoundingMode:o,dataFormat:i},d=r.E.runKernel(r.aU,c,p);return h?(0,r.h)(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),We=(0,r.w)({maxPoolWithArgmax_:function(e,n,t,a,s=!1){const o={x:(0,r.x)(e,"x","maxPoolWithArgmax")},i={filterSize:n,strides:t,pad:a,includeBatchInIndex:s},u=r.E.runKernel(r.aV,o,i);return{result:u[0],indexes:u[1]}}}),Re=(0,r.w)({maximum_:function(e,n){let t=(0,r.x)(e,"a","maximum"),a=(0,r.x)(n,"b","maximum");[t,a]=(0,r.y)(t,a),"bool"===t.dtype&&(t=(0,r.i)(t,"int32"),a=(0,r.i)(a,"int32")),(0,r.an)(t.shape,a.shape);const s={a:t,b:a};return r.E.runKernel(r.aW,s)}}),qe=(0,r.w)({mean_:function(e,n=null,t=!1){const a={x:(0,r.x)(e,"x","mean")},s={axis:n,keepDims:t};return r.E.runKernel(r.aX,a,s)}});function Oe(e,n="float32"){if("complex64"===n){const n=Oe(e,"float32"),t=(0,r.z)(e,"float32");return(0,r.d)(n,t)}const t=(0,a.P)((0,a.m)(e),n);return r.E.makeTensor(t,e,n)}const Pe=(0,r.w)({min_:function(e,n=null,t=!1){const a={x:(0,r.x)(e,"x","min")},s={axis:n,keepDims:t};return r.E.runKernel(r.aY,a,s)}}),He=(0,r.w)({minimum_:function(e,n){let t=(0,r.x)(e,"a","minimum"),a=(0,r.x)(n,"b","minimum");[t,a]=(0,r.y)(t,a),"bool"===t.dtype&&(t=(0,r.i)(t,"int32"),a=(0,r.i)(a,"int32")),(0,r.an)(t.shape,a.shape);const s={a:t,b:a};return r.E.runKernel(r.aZ,s)}}),Fe=(0,r.w)({mirrorPad_:function(e,n,t){(0,a.a)("reflect"===t||"symmetric"===t,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`));const s=(0,r.x)(e,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");(0,a.a)(n.length===s.rank,(()=>`Padding doesn't match input. Must be ${s.rank}. Got ${n.length}.`));const o="reflect"===t?1:0;for(let e=0;e<s.rank;e++)(0,a.a)(2===n[e].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,a.a)(n[e][0]>=0&&n[e][0]<=s.shape[e]-o&&n[e][1]>=0&&n[e][1]<=s.shape[e]-o,(()=>`Padding in dimension ${e} cannot be greater than or equal to ${s.shape[e]-o} or less than 0 for input of shape ${s.shape}`));const i={paddings:n,mode:t},u={x:s};return r.E.runKernel(r.a_,u,i)}}),Ve=(0,r.w)({mod_:function(e,n){let t=(0,r.x)(e,"a","mod"),a=(0,r.x)(n,"b","mod");[t,a]=(0,r.y)(t,a);const s={a:t,b:a};return r.E.runKernel(r.a$,s)}}),Be=(0,r.w)({square_:function(e){const n=(0,r.x)(e,"x","square");return r.E.runKernel("Square",{x:n},{})}}),Ge=(0,r.w)({multinomial_:function(e,n,t,a=!1){const s=(0,r.x)(e,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();const u={logits:1===i?(0,r.h)(s,[1,-1]):s},l={numSamples:n,seed:t,normalized:a},h=r.E.runKernel(r.b0,u,l);return 1===i?(0,r.h)(h,[h.size]):h}}),Le=(0,r.w)({notEqual_:function(e,n){let t=(0,r.x)(e,"a","notEqual","string_or_numeric"),a=(0,r.x)(n,"b","notEqual","string_or_numeric");[t,a]=(0,r.y)(t,a),(0,r.an)(t.shape,a.shape);const s={a:t,b:a};return r.E.runKernel(r.b1,s)}}),je=(0,r.w)({onesLike_:function(e){const n={x:(0,r.x)(e,"x","onesLike")};return r.E.runKernel(r.b2,n)}}),Ue=(0,r.w)({pad_:function(e,n,t=0){const a=(0,r.x)(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:n,constantValue:t},o={x:a};return r.E.runKernel(r.b3,o,s)}}),Ye=(0,r.w)({spaceToBatchND_:function(e,n,t){const s=(0,r.x)(e,"x","spaceToBatchND");(0,a.a)(s.rank>=1+n.length,(()=>`input rank ${s.rank} should be > than [blockShape] ${n.length}`)),(0,a.a)(t.length===n.length,(()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${n.length}`)),(0,a.a)(s.shape.reduce(((e,r,a)=>a>0&&a<=n.length?e&&(r+t[a-1][0]+t[a-1][1])%n[a-1]==0:e),!0),(()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${n.toString()}`));const o={x:s},i={blockShape:n,paddings:t};return r.E.runKernel(r.b4,o,i)}}),Ze=(0,r.w)({pow_:function(e,n){let t=(0,r.x)(e,"base","pow"),a=(0,r.x)(n,"exp","pow");[t,a]=(0,r.y)(t,a);const s={a:t,b:a};return r.E.runKernel(r.b5,s)}}),Xe=(0,r.w)({prod_:function(e,n=null,t=!1){let a=(0,r.x)(e,"x","prod");"bool"===a.dtype&&(a=(0,r.i)(a,"int32"));const s={x:a},o={axis:n,keepDims:t};return r.E.runKernel(r.b6,s,o)}});var Je=o((function(e){!function(e,n,t){function r(e){var n,t=this,r=(n=4022871197,function(e){e=e.toString();for(var t=0;t<e.length;t++){var r=.02519603282416938*(n+=e.charCodeAt(t));r-=n=r>>>0,n=(r*=n)>>>0,n+=4294967296*(r-=n)}return 2.3283064365386963e-10*(n>>>0)});t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=r(" "),t.s1=r(" "),t.s2=r(" "),t.s0-=r(e),t.s0<0&&(t.s0+=1),t.s1-=r(e),t.s1<0&&(t.s1+=1),t.s2-=r(e),t.s2<0&&(t.s2+=1),r=null}function a(e,n){return n.c=e.c,n.s0=e.s0,n.s1=e.s1,n.s2=e.s2,n}function s(e,n){var t=new r(e),s=n&&n.state,o=t.next;return o.int32=function(){return 4294967296*t.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,s&&("object"==typeof s&&a(s,t),o.state=function(){return a(t,{})}),o}n&&n.exports?n.exports=s:this.alea=s}(0,e)})),Qe=o((function(e){!function(e,n,t){function r(e){var n=this,t="";n.x=0,n.y=0,n.z=0,n.w=0,n.next=function(){var e=n.x^n.x<<11;return n.x=n.y,n.y=n.z,n.z=n.w,n.w^=n.w>>>19^e^e>>>8},e===(0|e)?n.x=e:t+=e;for(var r=0;r<t.length+64;r++)n.x^=0|t.charCodeAt(r),n.next()}function a(e,n){return n.x=e.x,n.y=e.y,n.z=e.z,n.w=e.w,n}function s(e,n){var t=new r(e),s=n&&n.state,o=function(){return(t.next()>>>0)/4294967296};return o.double=function(){do{var e=((t.next()>>>11)+(t.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=t.next,o.quick=o,s&&("object"==typeof s&&a(s,t),o.state=function(){return a(t,{})}),o}n&&n.exports?n.exports=s:this.xor128=s}(0,e)})),en=o((function(e){!function(e,n,t){function r(e){var n=this,t="";n.next=function(){var e=n.x^n.x>>>2;return n.x=n.y,n.y=n.z,n.z=n.w,n.w=n.v,(n.d=n.d+362437|0)+(n.v=n.v^n.v<<4^e^e<<1)|0},n.x=0,n.y=0,n.z=0,n.w=0,n.v=0,e===(0|e)?n.x=e:t+=e;for(var r=0;r<t.length+64;r++)n.x^=0|t.charCodeAt(r),r==t.length&&(n.d=n.x<<10^n.x>>>4),n.next()}function a(e,n){return n.x=e.x,n.y=e.y,n.z=e.z,n.w=e.w,n.v=e.v,n.d=e.d,n}function s(e,n){var t=new r(e),s=n&&n.state,o=function(){return(t.next()>>>0)/4294967296};return o.double=function(){do{var e=((t.next()>>>11)+(t.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=t.next,o.quick=o,s&&("object"==typeof s&&a(s,t),o.state=function(){return a(t,{})}),o}n&&n.exports?n.exports=s:this.xorwow=s}(0,e)})),nn=o((function(e){!function(e,n,t){function r(e){var n=this;n.next=function(){var e,t,r=n.x,a=n.i;return e=r[a],t=(e^=e>>>7)^e<<24,t^=(e=r[a+1&7])^e>>>10,t^=(e=r[a+3&7])^e>>>3,t^=(e=r[a+4&7])^e<<7,e=r[a+7&7],t^=(e^=e<<13)^e<<9,r[a]=t,n.i=a+1&7,t},function(e,n){var t,r=[];if(n===(0|n))r[0]=n;else for(n=""+n,t=0;t<n.length;++t)r[7&t]=r[7&t]<<15^n.charCodeAt(t)+r[t+1&7]<<13;for(;r.length<8;)r.push(0);for(t=0;t<8&&0===r[t];++t);for(8==t&&(r[7]=-1),e.x=r,e.i=0,t=256;t>0;--t)e.next()}(n,e)}function a(e,n){return n.x=e.x.slice(),n.i=e.i,n}function s(e,n){null==e&&(e=+new Date);var t=new r(e),s=n&&n.state,o=function(){return(t.next()>>>0)/4294967296};return o.double=function(){do{var e=((t.next()>>>11)+(t.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=t.next,o.quick=o,s&&(s.x&&a(s,t),o.state=function(){return a(t,{})}),o}n&&n.exports?n.exports=s:this.xorshift7=s}(0,e)})),tn=o((function(e){!function(e,n,t){function r(e){var n=this;n.next=function(){var e,t,r=n.w,a=n.X,s=n.i;return n.w=r=r+1640531527|0,t=a[s+34&127],e=a[s=s+1&127],t^=t<<13,e^=e<<17,t^=t>>>15,e^=e>>>12,t=a[s]=t^e,n.i=s,t+(r^r>>>16)|0},function(e,n){var t,r,a,s,o,i=[],u=128;for(n===(0|n)?(r=n,n=null):(n+="\0",r=0,u=Math.max(u,n.length)),a=0,s=-32;s<u;++s)n&&(r^=n.charCodeAt((s+32)%n.length)),0===s&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(o=o+1640531527|0,a=0==(t=i[127&s]^=r+o)?a+1:0);for(a>=128&&(i[127&(n&&n.length||0)]=-1),a=127,s=512;s>0;--s)r=i[a+34&127],t=i[a=a+1&127],r^=r<<13,t^=t<<17,r^=r>>>15,t^=t>>>12,i[a]=r^t;e.w=o,e.X=i,e.i=a}(n,e)}function a(e,n){return n.i=e.i,n.w=e.w,n.X=e.X.slice(),n}function s(e,n){null==e&&(e=+new Date);var t=new r(e),s=n&&n.state,o=function(){return(t.next()>>>0)/4294967296};return o.double=function(){do{var e=((t.next()>>>11)+(t.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=t.next,o.quick=o,s&&(s.X&&a(s,t),o.state=function(){return a(t,{})}),o}n&&n.exports?n.exports=s:this.xor4096=s}(0,e)})),rn=o((function(e){!function(e,n,t){function r(e){var n=this,t="";n.next=function(){var e=n.b,t=n.c,r=n.d,a=n.a;return e=e<<25^e>>>7^t,t=t-r|0,r=r<<24^r>>>8^a,a=a-e|0,n.b=e=e<<20^e>>>12^t,n.c=t=t-r|0,n.d=r<<16^t>>>16^a,n.a=a-e|0},n.a=0,n.b=0,n.c=-1640531527,n.d=1367130551,e===Math.floor(e)?(n.a=e/4294967296|0,n.b=0|e):t+=e;for(var r=0;r<t.length+20;r++)n.b^=0|t.charCodeAt(r),n.next()}function a(e,n){return n.a=e.a,n.b=e.b,n.c=e.c,n.d=e.d,n}function s(e,n){var t=new r(e),s=n&&n.state,o=function(){return(t.next()>>>0)/4294967296};return o.double=function(){do{var e=((t.next()>>>11)+(t.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=t.next,o.quick=o,s&&("object"==typeof s&&a(s,t),o.state=function(){return a(t,{})}),o}n&&n.exports?n.exports=s:this.tychei=s}(0,e)})),an=i(Object.freeze({__proto__:null,default:{}})),sn=o((function(e){!function(n,t){var r,a=this,s=256,o=t.pow(s,6),i=t.pow(2,52),u=2*i,l=255;function h(e,l,h){var m=[],b=f(d((l=1==l?{entropy:!0}:l||{}).entropy?[e,x(n)]:null==e?function(){try{var e;return r&&(e=r.randomBytes)?e=e(s):(e=new Uint8Array(s),(a.crypto||a.msCrypto).getRandomValues(e)),x(e)}catch(e){var t=a.navigator,o=t&&t.plugins;return[+new Date,a,o,a.screen,x(n)]}}():e,3),m),g=new c(m),w=function(){for(var e=g.g(6),n=o,t=0;e<i;)e=(e+t)*s,n*=s,t=g.g(1);for(;e>=u;)e/=2,n/=2,t>>>=1;return(e+t)/n};return w.int32=function(){return 0|g.g(4)},w.quick=function(){return g.g(4)/4294967296},w.double=w,f(x(g.S),n),(l.pass||h||function(e,n,r,a){return a&&(a.S&&p(a,g),e.state=function(){return p(g,{})}),r?(t.random=e,n):e})(w,b,"global"in l?l.global:this==t,l.state)}function c(e){var n,t=e.length,r=this,a=0,o=r.i=r.j=0,i=r.S=[];for(t||(e=[t++]);a<s;)i[a]=a++;for(a=0;a<s;a++)i[a]=i[o=l&o+e[a%t]+(n=i[a])],i[o]=n;(r.g=function(e){for(var n,t=0,a=r.i,o=r.j,i=r.S;e--;)n=i[a=l&a+1],t=t*s+i[l&(i[a]=i[o=l&o+n])+(i[o]=n)];return r.i=a,r.j=o,t})(s)}function p(e,n){return n.i=e.i,n.j=e.j,n.S=e.S.slice(),n}function d(e,n){var t,r=[],a=typeof e;if(n&&"object"==a)for(t in e)try{r.push(d(e[t],n-1))}catch(e){}return r.length?r:"string"==a?e:e+"\0"}function f(e,n){for(var t,r=e+"",a=0;a<r.length;)n[l&a]=l&(t^=19*n[l&a])+r.charCodeAt(a++);return x(n)}function x(e){return String.fromCharCode.apply(0,e)}if(t.seedrandom=h,f(t.random(),n),e.exports){e.exports=h;try{r=an}catch(e){}}}([],Math)}));sn.alea=Je,sn.xor128=Qe,sn.xorwow=en,sn.xorshift7=nn,sn.xor4096=tn,sn.tychei=rn;var on=sn;class un{constructor(e,n,t,r,a){this.mean=e,this.stdDev=n,this.dtype=t,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=on.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,n,t=!1;for(;!t;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*o,n=this.mean+this.stdDev*a*o,this.truncated&&!this.isValidTruncated(e)||(t=!0)}return this.truncated&&!this.isValidTruncated(n)||(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class ln{constructor(e,n,t,r){this.alpha=e,this.beta=1/n,this.dtype=t;const a=r||Math.random();this.randu=on.alea(a.toString()),this.randn=new un(0,1,t,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,t,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,n=1-.331*e*e,t=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<n||Math.log(a)<t)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class hn{constructor(e=0,n=1,t,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=n-e,this.dtype=t,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=on.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const cn=(0,r.w)({randomUniform_:function(e,n=0,t=1,a="float32",s){const o=(0,r.aw)(e,a),i=new hn(n,t,null,s);for(let e=0;e<o.values.length;e++)o.values[e]=i.nextValue();return o.toTensor()}});function pn(e,n,t=1,a="float32"){if(0===t)throw new Error("Cannot have a step of zero");const s={start:e,stop:n,step:t,dtype:a};return r.E.runKernel(r.b7,{},s)}const dn=(0,r.w)({real_:function(e){const n={input:(0,r.x)(e,"input","real")};return r.E.runKernel(r.b8,n)}}),fn=(0,r.w)({reciprocal_:function(e){const n={x:(0,r.x)(e,"x","reciprocal")};return r.E.runKernel(r.b9,n)}}),xn=(0,r.w)({reverse_:function(e,n){const t={x:(0,r.x)(e,"x","reverse")},a={dims:n};return r.E.runKernel(r.ba,t,a)}}),mn=(0,r.w)({round_:function(e){const n={x:(0,r.x)(e,"x","round")};return r.E.runKernel(r.bb,n)}}),bn=(0,r.w)({rsqrt_:function(e){const n={x:(0,r.x)(e,"x","rsqrt","float32")};return r.E.runKernel(r.bc,n)}}),gn=(0,r.w)({selu_:function(e){const n={x:(0,r.x)(e,"x","selu")};return r.E.runKernel(r.bd,n)}}),wn=async function(e,n){const t=(0,r.x)(e,"x","setdiff1d"),s=(0,r.x)(n,"y","setdiff1d");(0,a.a)(t.dtype===s.dtype,(()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`)),(0,a.a)(1===t.rank,(()=>`x should be 1D tensor, but got x (${t.shape}).`)),(0,a.a)(1===s.rank,(()=>`y should be 1D tensor, but got y (${s.shape}).`));const o=await t.data(),i=await s.data(),u=new Set(i);let l=0;for(let e=0;e<o.length;e++)u.has(o[e])||l++;const h=new r.be([l],t.dtype),c=new r.be([l],"int32");for(let e=0,n=0;e<o.length;e++)u.has(o[e])||(h.values[n]=o[e],c.values[n]=e,n++);return[h.toTensor(),c.toTensor()]},En=(0,r.w)({sign_:function(e){const n={x:(0,r.x)(e,"x","sign")};return r.E.runKernel(r.bf,n)}}),kn=(0,r.w)({sin_:function(e){const n={x:(0,r.x)(e,"x","sin","float32")};return r.E.runKernel(r.bg,n)}}),vn=(0,r.w)({sinh_:function(e){const n={x:(0,r.x)(e,"x","sinh")};return r.E.runKernel(r.bh,n)}}),yn=(0,r.w)({softmax_:function(e,n=-1){const t=(0,r.x)(e,"logits","softmax","float32");if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${n}`);const a={logits:t},s={dim:n};return r.E.runKernel(r.bi,a,s)}}),_n=(0,r.w)({fft_:function(e){(0,a.a)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const n={input:e};return r.E.runKernel(r.bj,n)}}),$n=(0,r.w)({ifft_:function(e){(0,a.a)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const n={input:e};return r.E.runKernel(r.bk,n)}}),Sn=(0,r.w)({irfft_:function(e){const n=e.shape[e.shape.length-1],t=e.size/n;let a;if(n<=2){const s=(0,r.h)(e,[t,n]);a=$n(s)}else{const s=[t,2*(n-1)],o=(0,r.h)(dn(e),[t,n]),i=(0,r.h)(xe(e),[t,n]),u=xn(C(o,[0,1],[t,n-2]),1),l=(0,r.m)(xn(C(i,[0,1],[t,n-2]),1),(0,r.f)(-1)),h=M([o,u],1),c=M([i,l],1),p=(0,r.h)((0,r.d)(h,c),[s[0],s[1]]);a=$n(p)}if(a=dn(a),3===e.rank&&0!==e.shape[0]){const n=a,t=e.shape[0];a=(0,r.h)(a,[t,a.shape[0]/t,a.shape[1]]),n.dispose()}return a}}),Nn=(0,r.w)({split_:function(e,n,t=0){const a={x:(0,r.x)(e,"x","split")},s={numOrSizeSplits:n,axis:t};return r.E.runKernel(r.bl,a,s)}}),Kn=(0,r.w)({rfft_:function(e,n){(0,a.a)("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let t=e.shape[e.shape.length-1];const s=e.size/t;let o;if(null!=n&&n<t){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=n,o=C(e,r,a),t=n}else if(null!=n&&n>t){const a=e.shape.map((e=>e));a[e.shape.length-1]=n-t,o=M([e,(0,r.z)(a)],e.shape.length-1),t=n}else o=e;const i=ne(o),u=(0,r.h)((0,r.d)(o,i),[s,t]),l=_n(u),h=Math.floor(t/2)+1,c=dn(l),p=xe(l),d=Nn(c,[h,t-h],c.shape.length-1),f=Nn(p,[h,t-h],p.shape.length-1),x=o.shape.slice();return x[o.shape.length-1]=h,(0,r.h)((0,r.d)(d[0],f[0]),x)}}),Tn=(0,r.w)({sqrt_:function(e){const n={x:(0,r.x)(e,"x","sqrt","float32")};return r.E.runKernel(r.bm,n)}}),Dn=(0,r.w)({squaredDifference_:function(e,n){let t=(0,r.x)(e,"a","squaredDifference"),a=(0,r.x)(n,"b","squaredDifference");[t,a]=(0,r.y)(t,a),(0,r.an)(t.shape,a.shape);const s={a:t,b:a};return r.E.runKernel(r.bn,s,{})}}),Mn=(0,r.w)({squeeze_:function(e,n){const t=(0,r.x)(e,"x","squeeze");return(0,r.h)(t,(0,a.A)(t.shape,n).newShape)}}),Cn=(0,r.w)({stack_:function(e,n=0){const t=(0,r.a2)(e,"tensors","stack","string_or_numeric");(0,a.a)(t.length>=1,(()=>"Pass at least one tensor to tf.stack")),t.length>0&&(0,a.a)(n<=t[0].rank,(()=>"Axis must be <= rank of the tensor"));const s=t,o={axis:n};return r.E.runKernel(r.bo,s,o)}}),zn=(0,r.w)({stridedSlice_:function(e,n,t,a,s=0,o=0,i=0,u=0,l=0){const h={x:(0,r.x)(e,"x","stridedSlice","string_or_numeric")},c={begin:n,end:t,strides:a,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:u,shrinkAxisMask:l};return r.E.runKernel(r.bp,h,c)}}),In=(0,r.w)({tan_:function(e){const n={x:(0,r.x)(e,"x","tan","float32")};return r.E.runKernel(r.bq,n)}});function An(e,n){(0,a.l)(e);const t=(0,r.C)(e,n);if(1!==t.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,r.D)(e,null,t,n)}function Wn(e,n,t){if((0,a.l)(e),null!=n&&2!==n.length)throw new Error("tensor2d() requires shape to have two numbers");const s=(0,r.C)(e,t);if(2!==s.length&&1!==s.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===s.length&&null==n)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,r.D)(e,n,s,t)}const Rn=(0,r.w)({topk_:function(e,n=1,t=!0){const a=(0,r.x)(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=a.shape[a.shape.length-1];if(n<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${n}`);if(n>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${n}`);const o={x:a},i={k:n,sorted:t},[u,l]=r.E.runKernel(r.br,o,i);return{values:u,indices:l}}}),qn=(0,r.w)({truncatedNormal_:function(e,n=0,t=1,a,s){if(null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const o=new un(n,t,a,!0,s),i=(0,r.aw)(e,a);for(let e=0;e<i.values.length;e++)i.values[e]=o.nextValue();return i.toTensor()}}),On=(0,r.w)({unique_:function(e,n=0){const t=(0,r.x)(e,"x","unique","string_or_numeric");(0,a.a)(t.rank>0,(()=>"The input tensor must be at least 1D"));const s={x:t},o={axis:n},[i,u]=r.E.runKernel(r.bs,s,o);return{values:i,indices:u}}}),Pn=(0,r.w)({unstack_:function(e,n=0){const t=(0,r.x)(e,"x","unstack","string_or_numeric");(0,a.a)(n>=-t.shape.length&&n<t.shape.length,(()=>`Axis = ${n} is not in [-${t.shape.length}, ${t.shape.length})`));const s={value:t},o={axis:n};return r.E.runKernel(r.bt,s,o)}}),Hn=async function(e){const n=(0,r.x)(e,"condition","whereAsync","bool"),t=await n.data(),a=(0,r.bu)(n.shape,t);return e!==n&&n.dispose(),a};function Fn(e,n,t=null){if(0===e.rank)return m(e);if(1!==e.rank&&null===t)return Fn((0,r.h)(e,[-1]),n,t);if(1===e.rank||"number"==typeof t||Array.isArray(t)&&1===t.length){if(1===n)return(0,r.j)(m(e),t);if(n===1/0)return Ne(m(e),t);if(n===-1/0)return Pe(m(e),t);if("euclidean"===n||2===n)return Tn((0,r.j)(Ze(m(e),(0,r.f)(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(t)&&2===t.length){if(1===n)return Ne((0,r.j)(m(e),t[0]),t[1]-1);if(n===1/0)return Ne((0,r.j)(m(e),t[1]),t[0]);if(n===-1/0)return Pe((0,r.j)(m(e),t[1]),t[0]);if("fro"===n||"euclidean"===n)return Tn((0,r.j)(Be(e),t));throw new Error(`Error in norm: invalid ord value: ${n}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Vn=(0,r.w)({norm_:function(e,n="euclidean",t=null,s=!1){const o=Fn(e=(0,r.x)(e,"x","norm"),n,t);let i=o.shape;if(s){const n=(0,a.z)(t,e.shape);i=(0,r.aP)(o.shape,n)}return(0,r.h)(o,i)}}),Bn=(0,r.w)({scatterND_:function(e,n,t){const a=(0,r.x)(e,"indices","scatterND","int32"),s=(0,r.x)(n,"updates","scatterND");(0,r.bv)(s,a,t);const o={indices:a,updates:s},i={shape:t};return r.E.runKernel(r.bw,o,i)}}),Gn=(0,r.w)({sparseToDense_:function(e,n,t,a=0){const s=(0,r.x)(e,"sparseIndices","sparseToDense","int32"),o=(0,r.x)(n,"sparseValues","sparseToDense"),i=(0,r.x)(a,"defaultValue","sparseToDense",o.dtype);!function(e,n,t,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);const o=n.size;if(0!==n.rank&&(1!==n.rank||o!==a))throw new Error(`sparseValues has incorrect shape ${n.shape}, should be [] or [${a}]`);if(n.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,o,t,i);const u={sparseIndices:s,sparseValues:o,defaultValue:i},l={outputShape:t};return r.E.runKernel(r.bx,u,l)}}),Ln=(0,r.w)({gatherND_:function(e,n){const t=(0,r.x)(n,"indices","gatherND","int32"),a={params:(0,r.x)(e,"x","gatherND","string_or_numeric"),indices:t};return r.E.runKernel(r.by,a)}});function jn(e,n,t){const r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){const o=2*Math.PI*s/(e+r-1);a[s]=n-t*Math.cos(o)}return An(a,"float32")}const Un=(0,r.w)({conv2DBackpropFilter_:function(e,n,t,s,o,i="NHWC",u){let l=e;3===e.rank&&(l=(0,r.h)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let h=n;3===h.rank&&(h=(0,r.h)(n,[1,n.shape[0],n.shape[1],n.shape[2]])),(0,a.a)(4===l.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${l.shape}.`)),(0,a.a)(4===h.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${h.shape}.`)),(0,a.a)(4===t.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`));const c="NHWC"===i?l.shape[3]:l.shape[1],p="NHWC"===i?h.shape[3]:h.shape[1];(0,a.a)(c===t[2],(()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`)),(0,a.a)(p===t[3],(()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${t[3]}).`)),(0,r.$)("conv2dDerFilter",o,u);const d={x:l,dy:h},f={strides:s,pad:o,dataFormat:i,dimRoundingMode:u,filterShape:t};return r.E.runKernel(r.bz,d,f)}}),Yn=(0,r.w)({fusedConv2d_:function({x:e,filter:n,strides:t,pad:s,dataFormat:o="NHWC",dilations:i=[1,1],dimRoundingMode:u,bias:l,activation:h="linear",preluActivationWeights:c,leakyreluAlpha:p}){if(h=h||"linear",!1===(0,r.bA)(r.E.state.gradientDepth,h)){let a=H(e,n,t,s,o,i,u);return null!=l&&(a=d(a,l)),(0,r.bB)(a,h,c,p)}const f=(0,r.x)(e,"x","conv2d","float32"),x=(0,r.x)(n,"filter","conv2d","float32");let m=f,b=!1;3===f.rank&&(b=!0,m=(0,r.h)(f,[1,f.shape[0],f.shape[1],f.shape[2]])),(0,a.a)(4===m.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${m.rank}.`)),(0,a.a)(4===x.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${x.rank}.`)),(0,r.$)("fused conv2d",s,u),(0,a.a)(m.shape[3]===x.shape[2],(()=>`Error in conv2d: depth of input (${m.shape[3]}) must match input depth for filter ${x.shape[2]}.`)),(0,a.a)((0,r._)(t,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`)),(0,a.a)("NHWC"===o,(()=>`Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`));const g=(0,r.bC)(m.shape,x.shape,t,i,s,u);let w,E;null!=l&&(w=(0,r.x)(l,"bias","fused conv2d"),[w]=(0,r.y)(w,f),(0,r.an)(g.outShape,w.shape)),null!=c&&(E=(0,r.x)(c,"prelu weights","fused conv2d"));const k=(e,n)=>{const[o,u,l,c]=n,p=(0,r.bE)(e,l,h);(0,a.a)((0,r.bF)(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));const d=[V(u.shape,p,o,t,s),Un(u,p,o.shape,t,s)];if(null!=c){const e=(0,r.bG)(c,p);d.push(e)}return d},v={x:m,filter:x,bias:w,preluActivationWeights:E},y={strides:t,pad:s,dataFormat:o,dilations:i,dimRoundingMode:u,activation:h,leakyreluAlpha:p};if(null==l){const e=_e(((e,n,t)=>{let a=r.E.runKernel(r.bD,v,y);return t([n,e,a]),b&&(a=(0,r.h)(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:k}}));return e(m,x)}{const e=_e(((e,n,t,a)=>{let s=r.E.runKernel(r.bD,v,y);return a([n,e,s,t]),b&&(s=(0,r.h)(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:k}}));return e(m,x,w)}}}),Zn=(0,r.w)({depthwiseConv2dNativeBackpropFilter_:function(e,n,t,a,s,o=[1,1],i){let u=e;3===e.rank&&(u=(0,r.h)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=n;3===l.rank&&(l=(0,r.h)(n,[1,n.shape[0],n.shape[1],n.shape[2]]));const h={x:u,dy:l},c={strides:a,pad:s,dimRoundingMode:i,dilations:o,filterShape:t};return r.E.runKernel(r.bH,h,c)}}),Xn=(0,r.w)({depthwiseConv2dNativeBackpropInput_:function(e,n,t,a,s,o=[1,1],i){let u=n,l=!1;3===n.rank&&(l=!0,u=(0,r.h)(n,[1,n.shape[0],n.shape[1],n.shape[2]]));const h={dy:u,filter:t},c={strides:a,pad:s,dimRoundingMode:i,dilations:o,inputShape:e},p=r.E.runKernel(r.bI,h,c);return l?(0,r.h)(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Jn=(0,r.w)({fusedDepthwiseConv2d_:function({x:e,filter:n,strides:t,pad:s,dataFormat:o="NHWC",dilations:i=[1,1],dimRoundingMode:u,bias:l,activation:h="linear",preluActivationWeights:c,leakyreluAlpha:p}){if(!1===(0,r.bA)(r.E.state.gradientDepth,h)){let a=X(e,n,t,s,o,i,u);return null!=l&&(a=d(a,l)),(0,r.bB)(a,h,c,p)}const f=(0,r.x)(e,"x","depthwiseConv2d","float32"),x=(0,r.x)(n,"filter","depthwiseConv2d","float32");let m=f,b=!1;3===f.rank&&(b=!0,m=(0,r.h)(f,[1,f.shape[0],f.shape[1],f.shape[2]])),(0,a.a)(4===m.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`)),(0,a.a)(4===x.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${x.rank}.`)),(0,a.a)(m.shape[3]===x.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${x.shape[2]}.`)),null==i&&(i=[1,1]),(0,a.a)((0,r._)(t,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`)),(0,r.$)("fused depthwiseConv2d",s,u);const g=(0,r.bC)(m.shape,x.shape,t,i,s,u,!0);let w,E;null!=l&&(w=(0,r.x)(l,"bias","fused conv2d"),[w]=(0,r.y)(w,f),(0,r.an)(g.outShape,w.shape)),null!=c&&(E=(0,r.x)(c,"prelu weights","fused depthwiseConv2d"));const k=(e,n)=>{(0,a.a)((0,r.bF)(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[o,l,c,p]=n,d=(0,r.bE)(e,c,h),f=Xn(l.shape,d,o,t,s,i,u),x=Zn(l,d,o.shape,t,s,i,u);return null!=p?[f,x,(0,r.bG)(w,d)]:[f,x]},v={x:m,filter:x,bias:w,preluActivationWeights:E},y={strides:t,pad:s,dataFormat:o,dilations:i,dimRoundingMode:u,activation:h,leakyreluAlpha:p};if(null==l){const e=_e(((e,n,t)=>{let a=r.E.runKernel(r.bJ,v,y);return t([n,e,a]),b&&(a=(0,r.h)(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:k}}));return e(m,x)}{const e=_e(((e,n,t,a)=>{let s=r.E.runKernel(r.bJ,v,y);return a([n,e,s,t]),b&&(s=(0,r.h)(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:k}}));return e(m,x,w)}}}),Qn=(0,r.w)({fusedMatMul_:function({a:e,b:n,transposeA:t=!1,transposeB:s=!1,bias:o,activation:i="linear",preluActivationWeights:l,leakyreluAlpha:h}){if(!1===(0,r.bA)(r.E.state.gradientDepth,i)){let a=u(e,n,t,s);return null!=o&&(a=d(a,o)),(0,r.bB)(a,i,l,h)}let c=(0,r.x)(e,"a","fused matMul"),p=(0,r.x)(n,"b","fused matMul");[c,p]=(0,r.y)(c,p);const f=t?c.shape[c.rank-2]:c.shape[c.rank-1],x=s?p.shape[p.rank-1]:p.shape[p.rank-2],m=t?c.shape[c.rank-1]:c.shape[c.rank-2],b=s?p.shape[p.rank-2]:p.shape[p.rank-1],g=c.shape.slice(0,-2),w=p.shape.slice(0,-2),E=(0,a.m)(g),k=(0,a.m)(w);(0,a.a)(f===x,(()=>`Error in fused matMul: inner shapes (${f}) and (${x}) of Tensors with shapes ${c.shape} and ${p.shape} and transposeA=${t} and transposeB=${s} must match.`));const v=(0,r.an)(c.shape.slice(0,-2),p.shape.slice(0,-2)).concat([m,b]),y=t?(0,r.h)(c,[E,f,m]):(0,r.h)(c,[E,m,f]),_=s?(0,r.h)(p,[k,b,x]):(0,r.h)(p,[k,x,b]);let $,S;null!=o&&($=(0,r.x)(o,"bias","fused matMul"),[$]=(0,r.y)($,c),(0,r.an)(v,$.shape)),null!=l&&(S=(0,r.x)(l,"prelu weights","fused matMul"));const N=(e,n)=>{const[a,l,h,c]=n,p=(0,r.bE)((0,r.h)(e,h.shape),h,i);let d,f;return t||s?!t&&s?(d=u(p,l,!1,!1),f=u(p,a,!0,!1)):t&&!s?(d=u(l,p,!1,!0),f=u(a,p,!1,!1)):(d=u(l,p,!0,!0),f=u(p,a,!0,!0)):(d=u(p,l,!1,!0),f=u(a,p,!0,!1)),null!=o?[d,f,(0,r.bG)(c,p)]:[d,f]},K={a:y,b:_,bias:$,preluActivationWeights:S},T={transposeA:t,transposeB:s,activation:i,leakyreluAlpha:h};if(null==o){const e=_e(((e,n,t)=>{const a=r.E.runKernel(r.bK,K,T);return t([e,n,a]),{value:(0,r.h)(a,v),gradFunc:N}}));return e(y,_)}{const e=_e(((e,n,t,a)=>{const s=r.E.runKernel(r.bK,K,T);return a([e,n,s,t]),{value:(0,r.h)(s,v),gradFunc:N}}));return e(y,_,$)}}});(0,r.w)({hammingWindow_:function(e){return jn(e,.54,.46)}});const et=(0,r.w)({hannWindow_:function(e){return jn(e,.5,.5)}}),nt=(0,r.w)({frame_:function(e,n,t,a=!1,s=0){let o=0;const i=[];for(;o+n<=e.size;)i.push(C(e,o,n)),o+=t;if(a)for(;o<e.size;){const r=o+n-e.size,a=M([C(e,o,n-r),he([r],s)]);i.push(a),o+=t}return 0===i.length?Wn([],[0,n]):(0,r.h)(M(i),[i.length,n])}});(0,r.w)({stft_:function(e,n,t,a,s=et){var o;null==a&&(o=n,a=Math.floor(Math.pow(2,Math.ceil(Math.log(o)/Math.log(2)))));const i=nt(e,n,t),u=(0,r.m)(i,s(n));return Kn(u,a)}});const tt=(0,r.w)({cropAndResize_:function(e,n,t,s,o="bilinear",i=0){const u=(0,r.x)(e,"image","cropAndResize"),l=(0,r.x)(n,"boxes","cropAndResize","float32"),h=(0,r.x)(t,"boxInd","cropAndResize","int32"),c=l.shape[0];(0,a.a)(4===u.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${u.rank}.`)),(0,a.a)(2===l.rank&&4===l.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${l.shape}.`)),(0,a.a)(1===h.rank&&h.shape[0]===c,(()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${l.shape}.`)),(0,a.a)(2===s.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`)),(0,a.a)(s[0]>=1&&s[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${s}`)),(0,a.a)("bilinear"===o||"nearest"===o,(()=>`method must be bilinear or nearest, but was ${o}`));const p={image:u,boxes:l,boxInd:h},d={method:o,extrapolationValue:i,cropSize:s};return r.E.runKernel(r.bL,p,d)}}),rt=(0,r.w)({flipLeftRight_:function(e){const n=(0,r.x)(e,"image","flipLeftRight","float32");(0,a.a)(4===n.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${n.rank}.`));const t={image:n};return r.E.runKernel(r.bM,t,{})}}),at=(0,r.w)({grayscaleToRGB_:function(e){const n=(0,r.x)(e,"image","grayscaleToRGB"),t=n.rank-1,s=n.shape[t];(0,a.a)(n.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${n.rank}.`)),(0,a.a)(1===s,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`));const o=new Array(n.rank);return o.fill(1,0,t),o[t]=3,ue(n,o)}}),st=(0,r.w)({rotateWithOffset_:function(e,n,t=0,s=.5){const o=(0,r.x)(e,"image","rotateWithOffset","float32");(0,a.a)(4===o.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`));const i={image:o},u={radians:n,fillValue:t,center:s};return r.E.runKernel(r.bN,i,u)}});function ot(e,n,t,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=e.shape[0];return t=Math.min(t,i),(0,a.a)(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),(0,a.a)(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),(0,a.a)(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),(0,a.a)(1===n.rank,(()=>"scores must be a 1D tensor")),(0,a.a)(n.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${n.shape[0]}`)),(0,a.a)(0<=o&&o<=1,(()=>`softNmsSigma must be in [0, 1], but was '${o}'`)),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const it=(0,r.w)({nonMaxSuppression_:function(e,n,t,a=.5,s=Number.NEGATIVE_INFINITY){const o=(0,r.x)(e,"boxes","nonMaxSuppression","float32"),i=(0,r.x)(n,"scores","nonMaxSuppression","float32"),u=ot(o,i,t,a,s),l={maxOutputSize:t=u.maxOutputSize,iouThreshold:a=u.iouThreshold,scoreThreshold:s=u.scoreThreshold};return r.E.runKernel(r.bO,{boxes:o,scores:i},l)}}),ut=(0,r.w)({nonMaxSuppressionWithScore_:function(e,n,t,a=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=(0,r.x)(e,"boxes","nonMaxSuppression"),u=(0,r.x)(n,"scores","nonMaxSuppression"),l=ot(i,u,t,a,s,o),h={boxes:i,scores:u},c={maxOutputSize:t=l.maxOutputSize,iouThreshold:a=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:o=l.softNmsSigma},p=r.E.runKernel(r.bQ,h,c);return{selectedIndices:p[0],selectedScores:p[1]}}}),lt=(0,r.w)({nonMaxSuppressionPadded_:function(e,n,t,a=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=(0,r.x)(e,"boxes","nonMaxSuppression"),u=(0,r.x)(n,"scores","nonMaxSuppression"),l=ot(i,u,t,a,s,null),h={boxes:i,scores:u},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:o},p=r.E.runKernel(r.bS,h,c);return{selectedIndices:p[0],validOutputs:p[1]}}}),ht=(0,r.w)({resizeBilinear_:function(e,n,t=!1,s=!1){const o=(0,r.x)(e,"images","resizeBilinear");(0,a.a)(3===o.rank||4===o.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`)),(0,a.a)(2===n.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${n}.`)),(0,a.a)(!1===s||!1===t,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let i=o,u=!1;3===o.rank&&(u=!0,i=(0,r.h)(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const l={images:i},h={alignCorners:t,halfPixelCenters:s,size:n},c=r.E.runKernel(r.bU,l,h);return u?(0,r.h)(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),ct=(0,r.w)({resizeNearestNeighbor_:function(e,n,t=!1,s=!1){const o=(0,r.x)(e,"images","resizeNearestNeighbor");(0,a.a)(3===o.rank||4===o.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`)),(0,a.a)(2===n.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${n}.`)),(0,a.a)("float32"===o.dtype||"int32"===o.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),(0,a.a)(!1===s||!1===t,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let i=o,u=!1;3===o.rank&&(u=!0,i=(0,r.h)(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const l={images:i},h={alignCorners:t,halfPixelCenters:s,size:n},c=r.E.runKernel(r.bV,l,h);return u?(0,r.h)(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),pt=(0,r.w)({threshold_:function(e,n="binary",t=!1,s=.5){const o=(0,r.x)(e,"image","threshold"),i=o.shape[0]*o.shape[1];let u,l,h,c,p=(0,r.m)(An([s]),255);if((0,a.a)(3===o.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`)),(0,a.a)(3===o.shape[2]||1===o.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`)),(0,a.a)("int32"===o.dtype||"float32"===o.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`)),(0,a.a)("otsu"===n||"binary"===n,(()=>`Method must be binary or otsu, but was ${n}`)),3===o.shape[2]){[u,l,h]=Nn(o,[1,1,1],-1);const e=(0,r.m)(u,.2989),n=(0,r.m)(l,.587),t=(0,r.m)(h,.114);c=d(d(e,n),t)}else c=e;"otsu"===n&&(p=function(e,n){let t,a,s,o,i,u,l=An([-1]),h=An([0]),c=An([0]);for(let p=0;p<e.size-1;p++){t=C(e,0,p+1),a=C(e,p+1),i=x((0,r.j)(t),n),u=x((0,r.j)(a),n);const f=(0,r.j)((0,r.m)(t,pn(0,t.size)));s=x(f,(0,r.j)(t));const m=he(a.shape,t.size),b=d(pn(0,a.size),m),g=(0,r.m)(a,b);o=x((0,r.j)(g),(0,r.j)(a));const w=Ke(s,o),E=Ke(s,o),k=(0,r.m)(i,u);c=(0,r.m)((0,r.m)(k,w),E);const v=de(c,h);h=ee(v,c,h),l=ee(v,An([p]),l)}return l}(W((0,r.i)(mn(c),"int32"),(0,r.t)([]),256),i));const f=t?ge(c,p):de(c,p);return(0,r.i)((0,r.m)(f,255),"int32")}}),dt=(0,r.w)({transform_:function(e,n,t="nearest",s="constant",o=0,i){const u=(0,r.x)(e,"image","transform","float32"),l=(0,r.x)(n,"transforms","transform","float32");(0,a.a)(4===u.rank,(()=>`Error in transform: image must be rank 4,but got rank ${u.rank}.`)),(0,a.a)(2===l.rank&&(l.shape[0]===u.shape[0]||1===l.shape[0])&&8===l.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),(0,a.a)(null==i||2===i.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`));const h={image:u,transforms:l},c={interpolation:t,fillMode:s,fillValue:o,outputShape:i};return r.E.runKernel(r.bW,h,c)}});function ft(e,n=!1){return r.E.tidy((()=>{(0,a.a)(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const t=e.shape[0],s=e.shape[1];let o=le(t),i=(0,r.c)(e);const l=Wn([[1]],[1,1]);let c=(0,r.c)(l);const p=t>=s?s:t;for(let e=0;e<p;++e){const n=i,a=c,p=o;[c,i,o]=r.E.tidy((()=>{const n=C(i,[e,e],[t-e,1]),a=Vn(n),p=C(i,[e,e],[1,1]),d=ee(de(p,0),Wn([[-1]]),Wn([[1]])),f=Ke(p,(0,r.m)(d,a)),m=x(n,f);c=1===m.shape[0]?(0,r.c)(l):M([l,C(m,[1,0],[m.shape[0]-1,m.shape[1]])],0);const b=$e(x(u(d,f),a)),g=C(i,[e,0],[t-e,s]),w=(0,r.m)(b,c),E=h(c);if(0===e)i=Ke(g,u(w,u(E,g)));else{const n=Ke(g,u(w,u(E,g)));i=M([C(i,[0,0],[e,s]),n],0)}const k=h(w),v=C(o,[0,e],[t,o.shape[1]-e]);if(0===e)o=Ke(v,u(u(v,c),k));else{const n=Ke(v,u(u(v,c),k));o=M([C(o,[0,0],[t,e]),n],1)}return[c,i,o]})),(0,r.v)([n,a,p])}return!n&&t>s&&(o=C(o,[0,0],[t,s]),i=C(i,[0,0],[s,s])),[o,i]}))}var xt;(0,r.w)({bandPart_:function(e,n,t){(0,a.a)(n%1==0,(()=>`bandPart(): numLower must be an integer, got ${n}.`)),(0,a.a)(t%1==0,(()=>`bandPart(): numUpper must be an integer, got ${t}.`));const s=(0,r.x)(e,"a","bandPart");(0,a.a)(s.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`));const o=s.shape,[i,u]=s.shape.slice(-2);if(!(n<=i))throw new Error(`bandPart(): numLower (${n}) must not be greater than the number of rows (${i}).`);if(!(t<=u))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${u}).`);n<0&&(n=i),t<0&&(t=u);const l=(0,r.h)(pn(0,i,1,"int32"),[-1,1]),h=pn(0,u,1,"int32"),c=Ke(l,h),p=Me(ge(c,(0,r.f)(+n,"int32")),fe(c,(0,r.f)(-t,"int32"))),d=(0,r.z)([i,u],s.dtype);return(0,r.h)(Cn(Pn((0,r.h)(s,[-1,i,u])).map((e=>ee(p,e,d)))),o)}}),(0,r.w)({gramSchmidt_:function(e){let n;if(Array.isArray(e)){n=!1,(0,a.a)(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const t=e[0].shape[0];for(let n=1;n<e.length;++n)(0,a.a)(e[n].shape[0]===t,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[n].shape[0]} vs. ${t})`))}else n=!0,e=Nn(e,e.shape[0],0).map((e=>Mn(e,[0])));(0,a.a)(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const t=[],s=e;for(let n=0;n<e.length;++n)t.push(r.E.tidy((()=>{let e=s[n];if(n>0)for(let a=0;a<n;++a){const n=(0,r.m)((0,r.j)((0,r.m)(t[a],e)),t[a]);e=Ke(e,n)}return x(e,Vn(e,"euclidean"))})));return n?Cn(t,0):t}}),(0,r.w)({qr_:function(e,n=!1){if((0,a.a)(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return ft(e,n);{const t=e.shape.slice(0,e.shape.length-2).reduce(((e,n)=>e*n)),a=Pn((0,r.h)(e,[t,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],o=[];return a.forEach((e=>{const[t,r]=ft(e,n);s.push(t),o.push(r)})),[(0,r.h)(Cn(s,0),e.shape),(0,r.h)(Cn(o,0),e.shape)]}}}),function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(xt||(xt={}));const mt=(0,r.w)({computeWeightedLoss_:function(e,n,t=xt.SUM_BY_NONZERO_WEIGHTS){const a=(0,r.x)(e,"losses","computeWeightedLoss");let s=null;null!=n&&(s=(0,r.x)(n,"weights","computeWeightedLoss"));const o=null==s?a:(0,r.m)(a,s);if(t===xt.NONE)return o;if(t===xt.SUM)return(0,r.j)(o);if(t===xt.MEAN){if(null==s)return qe(o);{const e=a.size/s.size,n=x((0,r.j)(o),(0,r.j)(s));return e>1?x(n,(0,r.f)(e)):n}}if(t===xt.SUM_BY_NONZERO_WEIGHTS){if(null==s)return x((0,r.j)(o),(0,r.f)(a.size));{const e=(0,r.m)(s,Oe(a.shape)),n=(0,r.i)((0,r.j)(Le(e,(0,r.f)(0))),"float32");return x((0,r.j)(o),n)}}throw Error(`Unknown reduction: ${t}`)}});(0,r.w)({absoluteDifference_:function(e,n,t,s=xt.SUM_BY_NONZERO_WEIGHTS){const o=(0,r.x)(e,"labels","absoluteDifference"),i=(0,r.x)(n,"predictions","absoluteDifference");let u=null;null!=t&&(u=(0,r.x)(t,"weights","absoluteDifference")),(0,a.k)(o.shape,i.shape,"Error in absoluteDifference: ");const l=m(Ke(o,i));return mt(l,u,s)}}),(0,r.w)({cosineDistance_:function(e,n,t,s,o=xt.SUM_BY_NONZERO_WEIGHTS){const i=(0,r.x)(e,"labels","cosineDistance"),u=(0,r.x)(n,"predictions","cosineDistance");let l=null;null!=s&&(l=(0,r.x)(s,"weights","cosineDistance")),(0,a.k)(i.shape,u.shape,"Error in cosineDistance: ");const h=(0,r.f)(1),c=Ke(h,(0,r.j)((0,r.m)(i,u),t,!0));return mt(c,l,o)}}),(0,r.w)({hingeLoss_:function(e,n,t,s=xt.SUM_BY_NONZERO_WEIGHTS){let o=(0,r.x)(e,"labels","hingeLoss");const i=(0,r.x)(n,"predictions","hingeLoss");let u=null;null!=t&&(u=(0,r.x)(t,"weights","hingeLoss")),(0,a.k)(o.shape,i.shape,"Error in hingeLoss: ");const l=(0,r.f)(1);o=Ke((0,r.m)((0,r.f)(2),o),l);const h=(0,r.a)(Ke(l,(0,r.m)(o,i)));return mt(h,u,s)}}),(0,r.w)({huberLoss_:function(e,n,t,s=1,o=xt.SUM_BY_NONZERO_WEIGHTS){const i=(0,r.x)(e,"labels","huberLoss"),u=(0,r.x)(n,"predictions","huberLoss");let l=null;null!=t&&(l=(0,r.x)(t,"weights","huberLoss")),(0,a.k)(i.shape,u.shape,"Error in huberLoss: ");const h=(0,r.f)(s),c=m(Ke(u,i)),p=He(c,h),f=Ke(c,p),x=d((0,r.m)((0,r.f)(.5),Be(p)),(0,r.m)(h,f));return mt(x,l,o)}}),(0,r.w)({logLoss_:function(e,n,t,s=1e-7,o=xt.SUM_BY_NONZERO_WEIGHTS){const i=(0,r.x)(e,"labels","logLoss"),u=(0,r.x)(n,"predictions","logLoss");let l=null;null!=t&&(l=(0,r.x)(t,"weights","logLoss")),(0,a.k)(i.shape,u.shape,"Error in logLoss: ");const h=(0,r.f)(1),c=(0,r.f)(s),p=$e((0,r.m)(i,ke(d(u,c)))),f=(0,r.m)(Ke(h,i),ke(d(Ke(h,u),c))),x=Ke(p,f);return mt(x,l,o)}}),(0,r.w)({meanSquaredError_:function(e,n,t,s=xt.SUM_BY_NONZERO_WEIGHTS){const o=(0,r.x)(e,"labels","meanSquaredError"),i=(0,r.x)(n,"predictions","meanSquaredError");let u=null;null!=t&&(u=(0,r.x)(t,"weights","meanSquaredError")),(0,a.k)(o.shape,i.shape,"Error in meanSquaredError: ");const l=Dn(o,i);return mt(l,u,s)}}),(0,r.w)({sigmoidCrossEntropy_:function(e,n,t,s=0,o=xt.SUM_BY_NONZERO_WEIGHTS){let i=(0,r.x)(e,"multiClassLabels","sigmoidCrossEntropy");const u=(0,r.x)(n,"logits","sigmoidCrossEntropy");let l=null;if(null!=t&&(l=(0,r.x)(t,"weights","sigmoidCrossEntropy")),(0,a.k)(i.shape,u.shape,"Error in sigmoidCrossEntropy: "),s>0){const e=(0,r.f)(s),n=(0,r.f)(1),t=(0,r.f)(.5);i=d((0,r.m)(i,Ke(n,e)),(0,r.m)(t,e))}const h=function(e,n){const t=(0,r.x)(e,"labels","sigmoidCrossEntropyWithLogits"),s=(0,r.x)(n,"logits","sigmoidCrossEntropyWithLogits");(0,a.k)(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const o=(0,r.a)(s),i=(0,r.m)(s,t),u=ve(se($e(m(s))));return d(Ke(o,i),u)}(i,u);return mt(h,l,o)}}),(0,r.w)({softmaxCrossEntropy_:function(e,n,t,s=0,o=xt.SUM_BY_NONZERO_WEIGHTS){let i=(0,r.x)(e,"onehotLabels","softmaxCrossEntropy");const u=(0,r.x)(n,"logits","softmaxCrossEntropy");let l=null;if(null!=t&&(l=(0,r.x)(t,"weights","softmaxCrossEntropy")),(0,a.k)(i.shape,u.shape,"Error in softmaxCrossEntropy: "),s>0){const e=(0,r.f)(s),n=(0,r.f)(1),t=(0,r.f)(i.shape[1]);i=d((0,r.m)(i,Ke(n,e)),x(e,t))}const h=function(e,n,t=-1){if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${n.rank} and dim was ${t}`);const a=_e(((e,n,a)=>{const s=De(n,[t],!0),o=Ke((0,r.i)(n,"float32"),s);a([e,o]);const i=$e((0,r.m)(o,e));return{value:(0,r.j)(i,[t]),gradFunc:(e,n)=>{const[a,s]=n,o=(0,r.aP)(e.shape,[t]);return[(0,r.m)((0,r.h)(e,o),Ke((0,r.i)(a,"float32"),se(s))),(0,r.m)((0,r.h)(e,o),Ke(se(s),(0,r.i)(a,"float32")))]}}}));return a(e,n)}(i,u);return mt(h,l,o)}});const bt=(0,r.w)({sparseFillEmptyRows_:function(e,n,t,a){const s=(0,r.x)(e,"indices","sparseFillEmptyRows","int32"),o=(0,r.x)(n,"values","sparseFillEmptyRows"),i=(0,r.x)(t,"denseShape","sparseFillEmptyRows","int32"),u=(0,r.x)(a,"defaultValue","sparseFillEmptyRows",o.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==o.rank)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==u.rank)throw new Error(`Default value should be a scalar but received shape ${u.shape}`);const l={indices:s,values:o,denseShape:i,defaultValue:u},h=r.E.runKernel(r.bX,l);return{outputIndices:h[0],outputValues:h[1],emptyRowIndicator:h[2],reverseIndexMap:h[3]}}}),gt=(0,r.w)({sparseReshape_:function(e,n,t){const a=(0,r.x)(e,"inputIndices","sparseReshape","int32"),s=(0,r.x)(n,"inputShape","sparseReshape","int32"),o=(0,r.x)(t,"newShape","sparseReshape","int32");if(2!==a.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i={inputIndices:a,inputShape:s,newShape:o},u=r.E.runKernel(r.bY,i);return{outputIndices:u[0],outputShape:u[1]}}}),wt=(0,r.w)({sparseSegmentMean_:function(e,n,t){const a=(0,r.x)(e,"data","sparseSegmentMean"),s=(0,r.x)(n,"indices","sparseSegmentMean","int32"),o=(0,r.x)(t,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${o.shape}`);const i={data:a,indices:s,segmentIds:o};return r.E.runKernel(r.bZ,i)}}),Et=(0,r.w)({sparseSegmentSum_:function(e,n,t){const a=(0,r.x)(e,"data","sparseSegmentSum"),s=(0,r.x)(n,"indices","sparseSegmentSum","int32"),o=(0,r.x)(t,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${o.shape}`);const i={data:a,indices:s,segmentIds:o};return r.E.runKernel(r.b_,i)}}),kt=(0,r.w)({stringNGrams_:function(e,n,t,a,s,o,i,u){const l=(0,r.x)(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const h=(0,r.x)(n,"dataSplits","stringNGrams");if("int32"!==h.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:a,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:u},p={data:l,dataSplits:h},d=r.E.runKernel(r.b$,p,c);return{nGrams:d[0],nGramsSplits:d[1]}}}),vt=(0,r.w)({stringSplit_:function(e,n,t=!0){const a=(0,r.x)(e,"input","stringSplit","string"),s=(0,r.x)(n,"delimiter","stringSplit","string");if(1!==a.rank)throw new Error(`Input should be Tensor1D but received shape ${a.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:t},i={input:a,delimiter:s},u=r.E.runKernel(r.c0,i,o);return{indices:u[0],values:u[1],shape:u[2]}}}),yt=(0,r.w)({stringToHashBucketFast_:function(e,n){const t=(0,r.x)(e,"input","stringToHashBucketFast","string"),a={numBuckets:n};if(n<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return r.E.runKernel(r.c1,s,a)}}),_t={flipLeftRight:rt,grayscaleToRGB:at,resizeNearestNeighbor:ct,resizeBilinear:ht,rotateWithOffset:st,cropAndResize:tt,nonMaxSuppression:it,nonMaxSuppressionAsync:async function(e,n,t,a=.5,s=Number.NEGATIVE_INFINITY){const o=(0,r.x)(e,"boxes","nonMaxSuppressionAsync"),i=(0,r.x)(n,"scores","nonMaxSuppressionAsync"),u=ot(o,i,t,a,s);t=u.maxOutputSize,a=u.iouThreshold,s=u.scoreThreshold;const l=await Promise.all([o.data(),i.data()]),h=l[0],c=l[1],{selectedIndices:p}=(0,r.bP)(h,c,t,a,s);return o!==e&&o.dispose(),i!==n&&i.dispose(),An(p,"int32")},nonMaxSuppressionWithScore:ut,nonMaxSuppressionWithScoreAsync:async function(e,n,t,a=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=(0,r.x)(e,"boxes","nonMaxSuppressionAsync"),u=(0,r.x)(n,"scores","nonMaxSuppressionAsync"),l=ot(i,u,t,a,s,o);t=l.maxOutputSize,a=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const h=await Promise.all([i.data(),u.data()]),c=h[0],p=h[1],{selectedIndices:d,selectedScores:f}=(0,r.bR)(c,p,t,a,s,o);return i!==e&&i.dispose(),u!==n&&u.dispose(),{selectedIndices:An(d,"int32"),selectedScores:An(f)}},nonMaxSuppressionPadded:lt,nonMaxSuppressionPaddedAsync:async function(e,n,t,a=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=(0,r.x)(e,"boxes","nonMaxSuppressionAsync"),u=(0,r.x)(n,"scores","nonMaxSuppressionAsync"),l=ot(i,u,t,a,s,null),h=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,[d,f]=await Promise.all([i.data(),u.data()]),{selectedIndices:x,validOutputs:m}=(0,r.bT)(d,f,h,c,p,o);return i!==e&&i.dispose(),u!==n&&u.dispose(),{selectedIndices:An(x,"int32"),validOutputs:(0,r.f)(m,"int32")}},threshold:pt,transform:dt},$t={sparseFillEmptyRows:bt,sparseReshape:gt,sparseSegmentMean:wt,sparseSegmentSum:Et},St={stringNGrams:kt,stringSplit:vt,stringToHashBucketFast:yt}}}]);