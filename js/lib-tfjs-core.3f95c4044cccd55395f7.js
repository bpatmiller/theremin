/*! For license information please see lib-tfjs-core.3f95c4044cccd55395f7.js.LICENSE.txt */
"use strict";(self.webpackChunktheremin=self.webpackChunktheremin||[]).push([[928],{2692:(a,t,e)=>{e.d(t,{CQI:()=>n.dB}),e(5389),e(3807),e(6282);var n=e(9839),r=e(5073),s=e(5912),i=e(8577);i.X,n.n,n.cX,n.q,n.d5,n.o,n.cW,n.c_,n.u,n.d6,n.d7,n.d8,n.d9,n.da,n.db,n.dc,n.dd,n.de,n.df,(0,n.w)({confusionMatrix_:function(a,t,e){const i=(0,n.x)(a,"labels","confusionMatrix"),o=(0,n.x)(t,"predictions","confusionMatrix");(0,s.a)(null==e||e>0&&Number.isInteger(e),(()=>`If provided, numClasses must be a positive integer, but got ${e}`)),(0,s.a)(1===i.rank,(()=>`Expected the rank of labels to be 1, but got ${i.rank}`)),(0,s.a)(1===o.rank,(()=>`Expected the rank of predictions to be 1, but got ${o.rank}`)),(0,s.a)(i.shape[0]===o.shape[0],(()=>`Mismatch in the number of examples: ${i.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`)),(0,s.a)(e>0&&Number.isInteger(e),(()=>`numClasses is required to be a positive integer, but got ${e}`));const c=(0,r.ag)((0,n.i)(i,"int32"),e),l=(0,r.ag)((0,n.i)(o,"int32"),e),u=(0,r.aB)(c),m=(0,r.aD)(u,l);return(0,n.i)(m,"int32")}});class o{constructor(){this.classNameMap={}}static getMap(){return null==o.instance&&(o.instance=new o),o.instance}static register(a){o.getMap().classNameMap[a.className]=[a,a.fromConfig]}}function c(a){(0,s.a)(null!=a.className,(()=>"Class being registered does not have the static className property defined.")),(0,s.a)("string"==typeof a.className,(()=>"className is required to be a string, but got type "+typeof a.className)),(0,s.a)(a.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),o.register(a)}(0,n.w)({basicLSTMCell_:function(a,t,e,s,i,o){const c=(0,n.x)(a,"forgetBias","basicLSTMCell"),l=(0,n.x)(t,"lstmKernel","basicLSTMCell"),u=(0,n.x)(e,"lstmBias","basicLSTMCell"),m=(0,n.x)(s,"data","basicLSTMCell"),h=(0,n.x)(i,"c","basicLSTMCell"),d=(0,n.x)(o,"h","basicLSTMCell"),g=(0,r.W)([m,d],1),p=(0,r.aD)(g,l),b=(0,r.i)(p,u),f=b.shape[0],k=b.shape[1]/4,v=[f,k],x=(0,r.Y)(b,[0,0],v),y=(0,r.Y)(b,[0,k],v),N=(0,r.Y)(b,[0,2*k],v),w=(0,r.Y)(b,[0,3*k],v),E=(0,r.i)((0,n.m)((0,n.s)(x),(0,r.n)(y)),(0,n.m)(h,(0,n.s)((0,r.i)(c,N))));return[E,(0,n.m)((0,r.n)(E),(0,n.s)(w))]}}),(0,n.w)({batchNorm2d_:function(a,t,e,i,o,c){const l=(0,n.x)(a,"x","batchNorm"),u=(0,n.x)(t,"mean","batchNorm"),m=(0,n.x)(e,"variance","batchNorm");let h,d;return null!=o&&(h=(0,n.x)(o,"scale","batchNorm")),null!=i&&(d=(0,n.x)(i,"offset","batchNorm")),(0,s.a)(2===l.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`)),(0,s.a)(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`)),(0,s.a)(2===m.rank||1===m.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${m.rank}.`)),null!=h&&(0,s.a)(2===h.rank||1===h.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${h.rank}.`)),null!=d&&(0,s.a)(2===d.rank||1===d.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`)),(0,r.aI)(l,u,m,d,h,c)}}),(0,n.w)({batchNorm3d_:function(a,t,e,i,o,c){const l=(0,n.x)(a,"x","batchNorm"),u=(0,n.x)(t,"mean","batchNorm"),m=(0,n.x)(e,"variance","batchNorm");let h,d;return null!=o&&(h=(0,n.x)(o,"scale","batchNorm")),null!=i&&(d=(0,n.x)(i,"offset","batchNorm")),(0,s.a)(3===l.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`)),(0,s.a)(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`)),(0,s.a)(3===m.rank||1===m.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${m.rank}.`)),null!=h&&(0,s.a)(3===h.rank||1===h.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${h.rank}.`)),null!=d&&(0,s.a)(3===d.rank||1===d.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`)),(0,r.aI)(l,u,m,d,h,c)}}),(0,n.w)({batchNorm4d_:function(a,t,e,i,o,c){const l=(0,n.x)(a,"x","batchNorm"),u=(0,n.x)(t,"mean","batchNorm"),m=(0,n.x)(e,"variance","batchNorm");let h,d;return null!=o&&(h=(0,n.x)(o,"scale","batchNorm")),null!=i&&(d=(0,n.x)(i,"offset","batchNorm")),(0,s.a)(4===l.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`)),(0,s.a)(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`)),(0,s.a)(4===m.rank||1===m.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${m.rank}.`)),null!=h&&(0,s.a)(4===h.rank||1===h.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${h.rank}.`)),null!=d&&(0,s.a)(4===d.rank||1===d.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`)),(0,r.aI)(l,u,m,d,h,c)}}),(0,n.w)({concat1d_:function(a){return(0,r.W)(a,0)}}),(0,n.w)({concat2d_:function(a,t){return(0,r.W)(a,t)}}),(0,n.w)({concat3d_:function(a,t){return(0,r.W)(a,t)}}),(0,n.w)({concat4d_:function(a,t){return(0,r.W)(a,t)}});const l=(0,n.w)({conv3DBackpropInput_:function(a,t,e,r,i){(0,s.a)(a.length===t.rank,(()=>`Length of inShape (${a.length}) and rank of dy (${t.rank}) must match`));let o=a,c=t,l=!1;4===t.rank&&(l=!0,c=(0,n.h)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,a[0],a[1],a[2],a[3]]);const u=o[4],m=c.shape[4];(0,s.a)(5===o.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`)),(0,s.a)(5===c.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${c.rank}`)),(0,s.a)(5===e.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`)),(0,s.a)(u===e.shape[3],(()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[3]}.`)),(0,s.a)(m===e.shape[4],(()=>`Error in conv3dDerInput: depth of output (${m}) must match output depth for filter ${e.shape[4]}.`));const h={dy:c,filter:e},d={pad:i,strides:r,inputShape:o},g=n.E.runKernel(n.cA,h,d);return l?(0,n.h)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}});(0,n.w)({conv3dTranspose_:function(a,t,e,r,s){const i=(0,n.x)(a,"x","conv3dTranspose"),o=(0,n.x)(t,"filter","conv3dTranspose");return l(e,i,o,r,s)}}),(0,n.w)({diag_:function(a){const t={x:(0,n.x)(a,"x","diag")};return n.E.runKernel(n.cC,t)}}),(0,n.w)({dot_:function(a,t){const e=(0,n.x)(a,"t1","dot"),i=(0,n.x)(t,"t2","dot");(0,s.a)(!(1!==e.rank&&2!==e.rank||1!==i.rank&&2!==i.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${i.rank}.`));const o=1===e.rank?e.size:e.shape[1],c=1===i.rank?i.size:i.shape[0];if((0,s.a)(o===c,(()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${c}.`)),1===e.rank&&1===i.rank){const a=(0,n.h)(e,[1,-1]),t=(0,n.h)(i,[-1,1]),s=(0,r.aD)(a,t);return(0,n.h)(s,[])}if(1===e.rank&&2===i.rank){const a=(0,n.h)(e,[1,-1]),t=(0,n.h)(i,[i.shape[0],i.shape[1]]),s=(0,r.aD)(a,t);return(0,n.h)(s,[s.size])}if(2===e.rank&&1===i.rank){const a=(0,n.h)(i,[-1,1]),t=(0,r.aD)(e,a);return(0,n.h)(t,[t.size])}{const a=(0,n.h)(i,[i.shape[0],i.shape[1]]);return(0,r.aD)(e,a)}}}),(0,n.w)({isFinite_:function(a){const t={x:(0,n.x)(a,"x","isFinite")};return n.E.runKernel(n.cG,t)}}),(0,n.w)({isInf_:function(a){const t={x:(0,n.x)(a,"x","isInf")};return n.E.runKernel(n.cH,t)}}),(0,n.w)({logSigmoid_:function(a){const t=(0,n.x)(a,"x","logSigmoid"),e=(0,r.bf)((a=>({value:(0,r.C)((0,r.u)((0,r.C)(a))),gradFunc:t=>(0,n.m)(t,(0,n.s)((0,r.C)(a)))})));return e(t)}}),(0,n.w)({logicalXor_:function(a,t){const e=(0,n.x)(a,"a","logicalXor","bool"),s=(0,n.x)(t,"b","logicalXor","bool");return(0,n.an)(e.shape,s.shape),(0,r.at)((0,r.ar)(a,t),(0,r.as)((0,r.at)(a,t)))}}),(0,n.w)({moments_:function(a,t=null,e=!1){a=(0,n.x)(a,"x","moments");const i=(0,s.z)(t,a.shape),o=(0,r.aR)(a,i,e);let c=o.shape;e||(c=(0,n.aP)(o.shape,i));const l=(0,r.o)((0,r.b)((0,n.i)(a,"float32"),(0,n.h)(o,c)));return{mean:o,variance:(0,r.aR)(l,i,e)}}}),(0,n.w)({multiRNNCell_:function(a,t,e,r){const s=(0,n.x)(t,"data","multiRNNCell"),i=(0,n.a2)(e,"c","multiRNNCell"),o=(0,n.a2)(r,"h","multiRNNCell");let c=s;const l=[];for(let t=0;t<a.length;t++){const e=a[t](c,i[t],o[t]);l.push(e[0]),l.push(e[1]),c=e[1]}const u=[],m=[];for(let a=0;a<l.length;a+=2)u.push(l[a]),m.push(l[a+1]);return[u,m]}}),(0,n.w)({outerProduct_:function(a,t){const e=(0,n.x)(a,"v1","outerProduct"),i=(0,n.x)(t,"v2","outerProduct");(0,s.a)(1===e.rank&&1===i.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${i.rank}.`));const o=(0,n.h)(e,[-1,1]),c=(0,n.h)(i,[1,-1]);return(0,r.aD)(o,c)}}),(0,n.w)({pad1d_:function(a,t,e=0){return(0,s.a)(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),(0,r.ba)(a,[t],e)}}),(0,n.w)({pad2d_:function(a,t,e=0){return(0,s.a)(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,r.ba)(a,t,e)}}),(0,n.w)({pad3d_:function(a,t,e=0){return(0,s.a)(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,r.ba)(a,t,e)}}),(0,n.w)({pad4d_:function(a,t,e=0){return(0,s.a)(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,r.ba)(a,t,e)}}),(0,n.w)({pool_:function(a,t,e,i,o,c,l){null==o&&(o=[1,1]),null==c&&(c=1),0===i&&(i="valid");const u=(0,n.x)(a,"x","maxPool");let m=u,h=!1;3===u.rank&&(h=!0,m=(0,n.h)(u,[1,u.shape[0],u.shape[1],u.shape[2]])),(0,s.a)((0,n._)(c,o),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${c} and dilations '${o}'`));const d=(0,n.cs)(m.shape,t,c,o,i),g=[d.dilationHeight,d.dilationWidth];let p;p="same"===i?function(a,t){const e=a.map(((a,e)=>a+(a-1)*(t[e]-1))).map((a=>a-1)),n=e.map((a=>Math.floor(a/2))),r=e.map(((a,t)=>a-n[t]));return e.map(((a,t)=>[n[t],r[t]]))}([d.filterHeight,d.filterWidth],g):[[0,0],[0,0]];const b=1===g[0]&&1===g[1],[f,k]=function(a,t,e){const n=e.map((a=>a[0])),r=e.map((a=>a[1])),s=a.concat(n,r),i=t.map(((a,t)=>(a-s[t]%a)%a)),o=r.map(((a,t)=>a+i[t]));return[t.map(((a,t)=>[n[t],o[t]])),t.map(((a,t)=>[0,i[t]]))]}([d.inHeight,d.inWidth],g,p),v=b?i:"valid",x=b?m:(0,r.b9)(m,g,f),y=("avg"===e?()=>(0,r.a2)(x,t,c,v,l):()=>(0,r.a1)(x,t,c,v,l))(),N=b?y:(0,r.b8)(y,g,k);return h?(0,n.h)(N,[N.shape[1],N.shape[2],N.shape[3]]):N}}),(0,n.w)({rand_:function(a,t,e){const r=(0,s.m)(a);let i=null;if(null==e||"float32"===e)i=new Float32Array(r);else if("int32"===e)i=new Int32Array(r);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);i=new Uint8Array(r)}for(let a=0;a<r;a++)i[a]=t();return n.E.makeTensor(i,a,e)}}),(0,n.w)({randomGamma_:function(a,t,e=1,s="float32",i){if(null==e&&(e=1),null==s&&(s="float32"),"float32"!==s&&"int32"!==s)throw new Error(`Unsupported data type ${s}`);const o=new r.bg(t,e,s,i),c=(0,n.aw)(a,s);for(let a=0;a<c.values.length;a++)c.values[a]=o.nextValue();return c.toTensor()}}),(0,n.w)({randomNormal_:function(a,t=0,e=1,s,i){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const o=new r.bh(t,e,s,!1,i),c=(0,n.aw)(a,s);for(let a=0;a<c.values.length;a++)c.values[a]=o.nextValue();return c.toTensor()}}),(0,n.w)({reverse1d_:function(a){const t=(0,n.x)(a,"x","reverse");return(0,s.a)(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),(0,r.aZ)(t,0)}}),(0,n.w)({reverse2d_:function(a,t){const e=(0,n.x)(a,"x","reverse");return(0,s.a)(2===e.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`)),(0,r.aZ)(e,t)}}),(0,n.w)({reverse3d_:function(a,t){const e=(0,n.x)(a,"x","reverse");return(0,s.a)(3===e.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`)),(0,r.aZ)(e,t)}}),(0,n.w)({reverse4d_:function(a,t){const e=(0,n.x)(a,"x","reverse");return(0,s.a)(4===e.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`)),(0,r.aZ)(e,t)}}),(0,n.w)({separableConv2d_:function(a,t,e,i,o,c=[1,1],l="NHWC"){const u=(0,n.x)(a,"x","separableConv2d"),m=(0,n.x)(t,"depthwiseFilter","separableConv2d"),h=(0,n.x)(e,"pointwiseFilter","separableConv2d");let d=u,g=!1;if(3===u.rank&&(g=!0,d=(0,n.h)(u,[1,u.shape[0],u.shape[1],u.shape[2]])),"NCHW"===l)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");(0,s.a)(4===d.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`)),(0,s.a)(4===m.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${m.rank}.`)),(0,s.a)(4===h.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${m.rank}.`)),(0,s.a)(1===h.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${h.shape[0]}.`)),(0,s.a)(1===h.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${h.shape[1]}.`));const p=m.shape[2],b=m.shape[3];(0,s.a)(h.shape[2]===p*b,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*b}, but got ${h.shape[2]}.`));const f=(0,r.a4)(d,m,i,o,l,c),k=(0,r.a8)(f,h,1,"valid",l);return g?(0,n.h)(k,[k.shape[1],k.shape[2],k.shape[3]]):k}}),(0,n.w)({slice1d_:function(a,t,e){const i=(0,n.x)(a,"x","slice1d");return(0,s.a)(1===i.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${i.rank} tensor`)),(0,r.Y)(i,[t],[e])}}),(0,n.w)({slice2d_:function(a,t,e){const i=(0,n.x)(a,"x","slice2d");return(0,s.a)(2===i.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${i.rank} tensor`)),(0,r.Y)(i,t,e)}}),(0,n.w)({slice3d_:function(a,t,e){const i=(0,n.x)(a,"x","slice3d");return(0,s.a)(3===i.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${i.rank} tensor`)),(0,r.Y)(i,t,e)}}),(0,n.w)({slice4d_:function(a,t,e){const i=(0,n.x)(a,"x","slice4d");return(0,s.a)(4===i.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${i.rank} tensor`)),(0,r.Y)(i,t,e)}}),(0,n.w)({unsortedSegmentSum_:function(a,t,e){const r=(0,n.x)(a,"x","unsortedSegmentSum"),i=(0,n.x)(t,"segmentIds","unsortedSegmentSum","int32");(0,s.a)((0,s.p)(e),(()=>"numSegments must be of dtype int"));const o={x:r,segmentIds:i},c={numSegments:e};return n.E.runKernel(n.cT,o,c)}}),(0,n.w)({movingAverage_:function(a,t,e,i,o=!0){const c=(0,n.x)(a,"v","movingAverage"),l=(0,n.x)(t,"x","movingAverage"),u=(0,n.x)(e,"decay","movingAverage");(0,n.dg)(c,l),(0,s.a)((0,s.b)(c.shape,l.shape),(()=>"Shape mismatch in v and x"));const m=(0,n.f)(1),h=(0,r.b)(m,u);let d=(0,n.m)((0,r.b)(l,c),h);if(o){(0,s.a)(null!=i,(()=>"When using zeroDebias: true, step is required."));const a=(0,n.x)(i,"step","movingAverage");d=(0,r.e)(d,(0,r.b)(m,(0,r.p)(u,a)))}return(0,r.i)(c,d)}}),(0,n.w)({dropout_:function(a,t,e,i){const o=(0,n.x)(a,"x","dropout");if((0,s.a)("float32"===o.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`)),(0,s.a)(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return a instanceof n.T?o.clone():o;const c=function(a,t){if(null==t)return a.shape.slice();if((0,s.b)(a.shape,t))return t;if(a.shape.length===t.length){const e=[];for(let n=0;n<a.shape.length;n++)null==t[n]&&null!=a.shape[n]?e.push(a.shape[n]):e.push(t[n]);return e}return t}(o,e),l=1-t,u=(0,r.e)((0,r.G)((0,r.i)((0,r.ad)(c,0,1,"float32",i),l)),l);return(0,n.m)(o,u)}}),r.a7,r.a6,r.aA;class u extends class{getClassName(){return this.constructor.className}static fromConfig(a,t){return new a(t)}}{minimize(a,t=!1,e){const{value:r,grads:s}=this.computeGradients(a,e);if(null!=e){const a=e.map((a=>({name:a.name,tensor:s[a.name]})));this.applyGradients(a)}else this.applyGradients(s);return(0,n.v)(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(a,t){return(0,r.bi)(a,t)}dispose(){null!=this.iterations_&&(0,n.v)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,n.f)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(a){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(a){return this.iterations_=(await a[0].tensor.data())[0],a.slice(1)}}Object.defineProperty(u,Symbol.hasInstance,{value:a=>null!=a.minimize&&null!=a.computeGradients&&null!=a.applyGradients});class m extends u{constructor(a,t,e=null){super(),this.learningRate=a,this.rho=t,this.epsilon=e,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==e&&(this.epsilon=n.E.backend.epsilon())}applyGradients(a){(Array.isArray(a)?a.map((a=>a.name)):Object.keys(a)).forEach(((t,e)=>{const s=n.E.registeredVariables[t];null==this.accumulatedGrads[e]&&(this.accumulatedGrads[e]={originalName:`${t}/accum_grad`,variable:(0,n.g)((()=>(0,r.aa)(s).variable(!1)))}),null==this.accumulatedUpdates[e]&&(this.accumulatedUpdates[e]={originalName:`${t}/accum_var`,variable:(0,n.g)((()=>(0,r.aa)(s).variable(!1)))});const i=Array.isArray(a)?a[e].tensor:a[t];if(null==i)return;const o=this.accumulatedGrads[e].variable,c=this.accumulatedUpdates[e].variable;(0,n.g)((()=>{const a=(0,r.i)((0,n.m)(o,this.rho),(0,n.m)((0,r.o)(i),1-this.rho)),t=(0,n.m)((0,r.e)((0,r.q)((0,r.i)(c,this.epsilon)),(0,r.q)((0,r.i)(o,this.epsilon))),i),e=(0,r.i)((0,n.m)(c,this.rho),(0,n.m)((0,r.o)(t),1-this.rho));o.assign(a),c.assign(e);const l=(0,r.i)((0,n.m)(t,-this.learningRate),s);s.assign(l)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,n.v)(this.accumulatedGrads.map((a=>a.variable))),(0,n.v)(this.accumulatedUpdates.map((a=>a.variable))))}async getWeights(){const a=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(a.map((a=>({name:a.originalName,tensor:a.variable}))))}async setWeights(a){const t=(a=await this.extractIterations(a)).length/2;this.accumulatedGrads=a.slice(0,t).map((a=>({originalName:a.name,variable:a.tensor.variable(!1)}))),this.accumulatedUpdates=a.slice(t,2*t).map((a=>({originalName:a.name,variable:a.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(a,t){return new a(t.learningRate,t.rho,t.epsilon)}}m.className="Adadelta",c(m);class h extends u{constructor(a,t=.1){super(),this.learningRate=a,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(a){(Array.isArray(a)?a.map((a=>a.name)):Object.keys(a)).forEach(((t,e)=>{const s=n.E.registeredVariables[t];if(null==this.accumulatedGrads[e]){const a=!1;this.accumulatedGrads[e]={originalName:`${t}/accumulator`,variable:(0,n.g)((()=>(0,r.aj)(s.shape,this.initialAccumulatorValue).variable(a)))}}const i=Array.isArray(a)?a[e].tensor:a[t];if(null==i)return;const o=this.accumulatedGrads[e].variable;(0,n.g)((()=>{const a=(0,r.i)(o,(0,r.o)(i));o.assign(a);const t=(0,r.i)((0,n.m)((0,r.e)(i,(0,r.q)((0,r.i)(a,n.E.backend.epsilon()))),-this.learningRate),s);s.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,n.v)(this.accumulatedGrads.map((a=>a.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((a=>({name:a.originalName,tensor:a.variable}))))}async setWeights(a){a=await this.extractIterations(a),this.accumulatedGrads=a.map((a=>({originalName:a.name,variable:a.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(a,t){return new a(t.learningRate,t.initialAccumulatorValue)}}h.className="Adagrad",c(h);class d extends u{constructor(a,t,e,r=null){super(),this.learningRate=a,this.beta1=t,this.beta2=e,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,n.g)((()=>{this.accBeta1=(0,n.f)(t).variable(),this.accBeta2=(0,n.f)(e).variable()})),null==r&&(this.epsilon=n.E.backend.epsilon())}applyGradients(a){const t=Array.isArray(a)?a.map((a=>a.name)):Object.keys(a);(0,n.g)((()=>{const e=(0,r.b)(1,this.accBeta1),s=(0,r.b)(1,this.accBeta2);t.forEach(((t,i)=>{const o=n.E.registeredVariables[t];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${t}/m`,variable:(0,n.g)((()=>(0,r.aa)(o).variable(!1)))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${t}/v`,variable:(0,n.g)((()=>(0,r.aa)(o).variable(!1)))});const c=Array.isArray(a)?a[i].tensor:a[t];if(null==c)return;const l=this.accumulatedFirstMoment[i].variable,u=this.accumulatedSecondMoment[i].variable,m=(0,r.i)((0,n.m)(l,this.beta1),(0,n.m)(c,1-this.beta1)),h=(0,r.i)((0,n.m)(u,this.beta2),(0,n.m)((0,r.o)(c),1-this.beta2)),d=(0,r.e)(m,e),g=(0,r.e)(h,s);l.assign(m),u.assign(h);const p=(0,r.i)((0,n.m)((0,r.e)(d,(0,r.i)((0,r.q)(g),this.epsilon)),-this.learningRate),o);o.assign(p)})),this.accBeta1.assign((0,n.m)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,n.m)(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,n.v)(this.accumulatedFirstMoment.map((a=>a.variable))),null!=this.accumulatedSecondMoment&&(0,n.v)(this.accumulatedSecondMoment.map((a=>a.variable)))}async getWeights(){const a=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(a.map((a=>({name:a.originalName,tensor:a.variable}))))}async setWeights(a){a=await this.extractIterations(a),(0,n.g)((()=>{this.accBeta1.assign((0,r.p)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,r.p)(this.beta2,this.iterations_+1))}));const t=a.length/2;this.accumulatedFirstMoment=a.slice(0,t).map((a=>({originalName:a.name,variable:a.tensor.variable(!1)}))),this.accumulatedSecondMoment=a.slice(t,2*t).map((a=>({originalName:a.name,variable:a.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(a,t){return new a(t.learningRate,t.beta1,t.beta2,t.epsilon)}}d.className="Adam",c(d);class g extends u{constructor(a,t,e,r=null,s=0){super(),this.learningRate=a,this.beta1=t,this.beta2=e,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,n.g)((()=>{this.iteration=(0,n.f)(0).variable(),this.accBeta1=(0,n.f)(t).variable()})),null==r&&(this.epsilon=n.E.backend.epsilon())}applyGradients(a){const t=Array.isArray(a)?a.map((a=>a.name)):Object.keys(a);(0,n.g)((()=>{const e=(0,r.b)(1,this.accBeta1),s=(0,r.e)(-this.learningRate,(0,r.i)((0,n.m)(this.iteration,this.decay),1));t.forEach(((t,i)=>{const o=n.E.registeredVariables[t];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${t}/m`,variable:(0,r.aa)(o).variable(!1)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${t}/v`,variable:(0,r.aa)(o).variable(!1)});const c=Array.isArray(a)?a[i].tensor:a[t];if(null==c)return;const l=this.accumulatedFirstMoment[i].variable,u=this.accumulatedWeightedInfNorm[i].variable,m=(0,r.i)((0,n.m)(l,this.beta1),(0,n.m)(c,1-this.beta1)),h=(0,n.m)(u,this.beta2),d=(0,r.U)(c),g=(0,r.m)(h,d);l.assign(m),u.assign(g);const p=(0,r.i)((0,n.m)((0,r.e)(s,e),(0,r.e)(m,(0,r.i)(g,this.epsilon))),o);o.assign(p)})),this.iteration.assign((0,r.i)(this.iteration,1)),this.accBeta1.assign((0,n.m)(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,n.v)(this.accumulatedFirstMoment.map((a=>a.variable))),null!=this.accumulatedWeightedInfNorm&&(0,n.v)(this.accumulatedWeightedInfNorm.map((a=>a.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(a){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(a,t){return new a(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}g.className="Adamax",c(g);class p extends u{constructor(a){super(),this.learningRate=a,this.setLearningRate(a)}applyGradients(a){(Array.isArray(a)?a.map((a=>a.name)):Object.keys(a)).forEach(((t,e)=>{const s=Array.isArray(a)?a[e].tensor:a[t];if(null==s)return;const i=n.E.registeredVariables[t];(0,n.g)((()=>{const a=(0,r.i)((0,n.m)(this.c,s),i);i.assign(a)}))})),this.incrementIterations()}setLearningRate(a){this.learningRate=a,null!=this.c&&this.c.dispose(),this.c=(0,n.k)((0,n.f)(-a))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(a){if(0!==(a=await this.extractIterations(a)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(a,t){return new a(t.learningRate)}}p.className="SGD",c(p);class b extends p{constructor(a,t,e=!1){super(a),this.learningRate=a,this.momentum=t,this.useNesterov=e,this.accumulations=[],this.m=(0,n.f)(this.momentum)}applyGradients(a){(Array.isArray(a)?a.map((a=>a.name)):Object.keys(a)).forEach(((t,e)=>{const s=n.E.registeredVariables[t];if(null==this.accumulations[e]){const a=!1;this.accumulations[e]={originalName:`${t}/momentum`,variable:(0,n.g)((()=>(0,r.aa)(s).variable(a)))}}const i=this.accumulations[e].variable,o=Array.isArray(a)?a[e].tensor:a[t];null!=o&&(0,n.g)((()=>{let a;const t=(0,r.i)((0,n.m)(this.m,i),o);a=this.useNesterov?(0,r.i)((0,n.m)(this.c,(0,r.i)(o,(0,n.m)(t,this.m))),s):(0,r.i)((0,n.m)(this.c,t),s),i.assign(t),s.assign(a)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,n.v)(this.accumulations.map((a=>a.variable)))}setMomentum(a){this.momentum=a}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((a=>({name:a.originalName,tensor:a.variable}))))}async setWeights(a){a=await this.extractIterations(a),this.accumulations=a.map((a=>({originalName:a.name,variable:a.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(a,t){return new a(t.learningRate,t.momentum,t.useNesterov)}}b.className="Momentum",c(b);class f extends u{constructor(a,t=.9,e=0,r=null,s=!1){if(super(),this.learningRate=a,this.decay=t,this.momentum=e,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=n.E.backend.epsilon()),null==a)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(a){(Array.isArray(a)?a.map((a=>a.name)):Object.keys(a)).forEach(((t,e)=>{const s=n.E.registeredVariables[t],i=!1;null==this.accumulatedMeanSquares[e]&&(this.accumulatedMeanSquares[e]={originalName:`${t}/rms`,variable:(0,n.g)((()=>(0,r.aa)(s).variable(i)))}),null==this.accumulatedMoments[e]&&(this.accumulatedMoments[e]={originalName:`${t}/momentum`,variable:(0,n.g)((()=>(0,r.aa)(s).variable(i)))}),null==this.accumulatedMeanGrads[e]&&this.centered&&(this.accumulatedMeanGrads[e]={originalName:`${t}/mg`,variable:(0,n.g)((()=>(0,r.aa)(s).variable(i)))});const o=Array.isArray(a)?a[e].tensor:a[t];if(null==o)return;const c=this.accumulatedMeanSquares[e].variable,l=this.accumulatedMoments[e].variable;(0,n.g)((()=>{const a=(0,r.i)((0,n.m)(c,this.decay),(0,n.m)((0,r.o)(o),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[e].variable,i=(0,r.i)((0,n.m)(t,this.decay),(0,n.m)(o,1-this.decay)),u=(0,r.e)((0,n.m)(o,this.learningRate),(0,r.q)((0,r.b)(a,(0,r.i)((0,r.o)(i),this.epsilon)))),m=(0,r.i)((0,n.m)(l,this.momentum),u);c.assign(a),t.assign(i),l.assign(m);const h=(0,r.b)(s,m);s.assign(h)}else{const a=(0,r.i)((0,n.m)(c,this.decay),(0,n.m)((0,r.o)(o),1-this.decay)),t=(0,r.i)((0,n.m)(l,this.momentum),(0,r.e)((0,n.m)(o,this.learningRate),(0,r.q)((0,r.i)(a,this.epsilon))));c.assign(a),l.assign(t);const e=(0,r.b)(s,t);s.assign(e)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,n.v)(this.accumulatedMeanSquares.map((a=>a.variable))),null!=this.accumulatedMeanGrads&&this.centered&&(0,n.v)(this.accumulatedMeanGrads.map((a=>a.variable))),null!=this.accumulatedMoments&&(0,n.v)(this.accumulatedMoments.map((a=>a.variable)))}async getWeights(){const a=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&a.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(a.map((a=>({name:a.originalName,tensor:a.variable}))))}async setWeights(a){a=await this.extractIterations(a);const t=this.centered?a.length/3:a.length/2,e=!1;this.accumulatedMeanSquares=a.slice(0,t).map((a=>({originalName:a.name,variable:a.tensor.variable(e)}))),this.accumulatedMoments=a.slice(t,2*t).map((a=>({originalName:a.name,variable:a.tensor.variable(e)}))),this.centered&&(this.accumulatedMeanGrads=a.slice(2*t,3*t).map((a=>({originalName:a.name,variable:a.tensor.variable(e)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(a,t){return new a(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}f.className="RMSProp",c(f),"undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate&&setImmediate,n.bP,n.bT,n.bR,n.bu}}]);