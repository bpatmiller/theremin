/*! For license information please see index.f464b1c65fef2349dc87.js.LICENSE.txt */
"use strict";(self.webpackChunktheremin=self.webpackChunktheremin||[]).push([[927],{8577:(e,t,n)=>{n.d(t,{A:()=>I,B:()=>v,C:()=>j,D:()=>V,E:()=>J,F:()=>H,G:()=>X,H:()=>U,I:()=>P,J:()=>C,K:()=>G,L:()=>W,M:()=>B,N:()=>u,O:()=>fe,P:()=>k,Q:()=>z,R:()=>K,S:()=>T,T:()=>$,U:()=>c,V:()=>ce,W:()=>he,X:()=>l,a:()=>ge,b:()=>me,c:()=>E,d:()=>Y,e:()=>ee,f:()=>de,g:()=>Q,h:()=>te,i:()=>A,j:()=>ne,k:()=>re,l:()=>ie,m:()=>oe,n:()=>se,o:()=>ae,p:()=>le,q:()=>ue,r:()=>L,s:()=>F,t:()=>S,u:()=>h,v:()=>D,w:()=>O,x:()=>R,y:()=>N,z:()=>_}),n(5389),n(3807);var r=n(9839),i=n(5912);function o(e){return new Promise((e=>setTimeout(e))).then(e)}class s{constructor(e){if(!(0,r.e)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(s.URL_SCHEME)&&(e=e.slice(s.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=(0,r.cZ)(e,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=s,await o((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await o((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:(0,r.c_)(e)}}}}s.URL_SCHEME="downloads://";class a{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const i=JSON.parse(n.target.result),o=i.modelTopology;if(null==o)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==i.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:o});const s=(0,r.cW)(i,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const r of e)t.push(...r.weights),n.push(...r.paths);const i=this.checkManifestAndWeightFiles(e),o=n.map((e=>this.loadWeightsFile(e,i[e])));return Promise.all(o).then((e=>[t,(0,r.cX)(e)]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const i=new FileReader;i.onload=e=>{const t=e.target.result;n(t)},i.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>(0,r.cY)(e.name))),i={};for(const o of e)o.paths.forEach((e=>{const o=(0,r.cY)(e);if(-1!==t.indexOf(o))throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),-1===n.indexOf(o))throw new Error(`Weight file with basename '${o}' is not provided.`);i[e]=this.weightsFiles[n.indexOf(o)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}function l(e){return new a(e)}function u(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===(0,i.m)(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const o=t.shape,s=o[o.length-1];let a=1;for(let e=0;e<o.length-1;++e)a*=o[e];const l=e.shape,u=o.slice();u.pop();let h=1;for(let e=s;e<n;++e)h*=l[e],u.push(l[e]);const c=[...(0,i.O)(e.shape).map((e=>e/h)),1].slice(0,s);return[u,a,h,c]}function h(e,t,n){const r=e.shape.length;(0,i.a)(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),(0,i.a)(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let o=0;o<r;++o)(0,i.a)(t[o]+n[o]<=e.shape[o],(()=>`Error in slice${r}D: begin[${o}] + size[${o}] (${t[o]+n[o]}) would overflow input.shape[${o}] (${e.shape[o]})`))}function c(e,t,n){const r=[];for(let i=0;i<e.length;i++)r[i]=Math.ceil((t[i]-e[i])/n[i]);return r}function f(e,t,n,r){const i=[...e];for(let e=i.length;e<r.length;e++)i.push(1);for(let e=0;e<n;e++)0===e?i[t]=1:(i.splice(t,0,1),i.pop());return i}function p(e,t,n){return n<=e?n:n-(t-1)}function d(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function g(e,t,n,r,i){const o=[...i],s=d(n,t);for(let i=0;i<o.length;i++)if(s.indexOf(i)>-1)o[i]=0;else{const s=p(t,n,i);let a=r[s];e&1<<s&&(a=0),o[i]=a}return o}function m(e,t,n,r,o){const s=[...o],a=d(n,t);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{const o=p(t,n,i);let a=r[o];e&1<<o&&(a=Number.MAX_SAFE_INTEGER),s[i]=a}for(let e=0;e<s.length;e++){const t=o[e];s[e]<0&&(s[e]+=t),s[e]=(0,i.e)(0,s[e],o[e])}return s}function w(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function y(e,t,n,r,o,s){let a=t[o];const l=n[o]||1;(e&1<<o||s&1<<o||null==a)&&(a=l>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=r[o];return a<0&&(a+=u),a=(0,i.e)(0,a,u-1),a}function b(e,t,n,r,o,s){let a=t[o];const l=n[o]||1;(e&1<<o||s&1<<o||null==a)&&(a=l>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=r[o];return a<0&&(a+=u),a=l>0?(0,i.e)(0,a,u):(0,i.e)(-1,a,u-1),a}function A(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let i=r+1;i<n.length;i++)if(t[i]>0||n[i]!==e[i])return!1;return!0}function E(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function S(e,t,n){let r;const o=e.shape.length;let s;return r="number"==typeof t?[t,...new Array(o-1).fill(0)]:t.length<o?t.concat(new Array(o-t.length).fill(0)):t.slice(),r.forEach((e=>{(0,i.a)(-1!==e,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(o).fill(-1):"number"==typeof n?[n,...new Array(o-1).fill(-1)]:n.length<o?n.concat(new Array(o-n.length).fill(-1)):n,s=s.map(((t,n)=>t>=0?t:((0,i.a)(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,s]}function $(e,t,n,r,i,o,s,a,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=s&&0!=(s&s-1))throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const c={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:i,endMask:o,ellipsisMask:s,newAxisMask:a,shrinkAxisMask:l};for(let e=0;e<c.dims;e++)h&&0!=(1<<e&a)&&c.numAddAxisAfterEllipsis++,1<<e&s&&(h=!0);h||(c.ellipsisMask|=1<<c.dims,c.dims++);const f={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const i=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<i;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(c,f);let p=!0,d=!0,g=!0;const m=[],w=[];for(let t=0;t<e.length;++t){if(0===f.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(f.shrinkAxisMask&1<<t),r=e[t];if(-1===r){m.push(n?1:-1);continue}const i=[f.beginMask&1<<t,f.endMask&1<<t],o=[f.strides[t]>0?0:-1,f.strides[t]>0?r:r-1];if(n&&f.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===f.strides[t];const s=!!(f.beginMask&1<<t&&f.endMask&1<<t);if(f.beginValid&&f.endValid){if(n){const e=f.begin[t]<0?r+f.begin[t]:f.begin[t];if(f.begin[t]=e,f.end[t]=f.begin[t]+1,e<0||e>=r)throw Error(`slice index ${f.begin[t]} of dimension ${t} out of bounds.`)}else f.begin[t]=M(f.begin[t],0,f.strides[t],r,i,o),f.end[t]=M(f.end[t],1,f.strides[t],r,i,o);const e=1===f.strides[t]&&0===f.begin[t]&&f.end[t]===r;p=p&&e,d=d&&(0===t&&1===f.strides[t]||e)}else p=p&&1===f.strides[t]&&s,d=d&&(0===t&&1===f.strides[t]||s);let a,l=!1;if(f.beginValid&&f.endValid?(a=f.end[t]-f.begin[t],l=!0):n?(a=1,l=!0):s&&r>=0&&(a=f.strides[t]<0?-r:r,l=!0),l){let e;e=0===a||a<0!=f.strides[t]<0?0:Math.trunc(a/f.strides[t])+(a%f.strides[t]!=0?1:0),m.push(e)}else m.push(-1)}for(let e=0;e<f.finalShapeGatherIndices.length;++e){const t=f.finalShapeGatherIndices[e];t>=0?w.push(m[t]):-2===t&&w.push(1)}return{finalShapeSparse:w.filter(((e,t)=>-2!==f.finalShapeGatherIndices[t])),finalShape:w,isIdentity:p,sliceDim0:d,isSimpleSlice:g,begin:f.begin,end:f.end,strides:f.strides}}function M(e,t,n,r,i,o){if(i[t])return n>0?o[t]:o[t+1&1];{const t=e<0?r+e:e;return t<o[0]?o[0]:t>o[1]?o[1]:t}}r.cV.registerSaveRouter((e=>(0,r.e)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(s.URL_SCHEME)?function(e="model"){return new s(e)}(e.slice(s.URL_SCHEME.length)):null));var x=Object.freeze({__proto__:null,assertParamsValid:h,maskToAxes:function(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t},computeOutShape:c,stridesWithElidedDims:f,getNormalizedAxes:function(e,t,n,r,i,o,s,a,l){const u=e.length;let h=new Array(u),c=new Array(u),p=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;h=g(s,l,u,r,e),c=m(a,l,u,i,e),p=f(o,l,u,e)}else for(let t=0;t<u;t++)h[t]=y(s,r,o,e,t,l),c[t]=b(a,i,o,e,t,l),p[t]=w(o,t,l);return{begin:h,end:c,strides:p}},startIndicesWithElidedDims:g,stopIndicesWithElidedDims:m,stridesForAxis:w,startForAxis:y,stopForAxis:b,isSliceContinous:A,computeFlatOffset:E,parseSliceParams:S,sliceInfo:$});function v(e,t){const n=e[0].length;e.forEach(((e,t)=>{(0,i.a)(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),(0,i.a)(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,o)=>{for(let s=0;s<n;s++)(0,i.a)(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${o}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`))}))}function I(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function F(e){return e<=30?e:(0,i.N)(e,Math.floor(Math.sqrt(e)))}function k(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function D(e,t,n,r=!0){let i=[];if(r)i=i.concat(t.slice(0)),i.push(e[0]/n),i=i.concat(e.slice(1));else{i=i.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)i=i.concat([e[r+1]/t[r],t[r]]);i=i.concat(e.slice(n+1))}return i}function O(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],i=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?i.push(r):n.push(r);r.push(...n),r.push(0),r.push(...i)}return r}function R(e,t,n,r=!0){const i=[];r?i.push(e[0]/n):i.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?i.push(t[n-1]*e[n]):i.push(e[n]/t[n-1]):i.push(e[n]);return i}function N(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function _(e,t,n){const r=e.slice(0,1);for(let i=0;i<n;++i)r.push(e[i+1]-t[i][0]-t[i][1]);return r}const T=1.7580993408473768,z=1.0507009873554805,U=.3275911,P=.254829592,C=-.284496736,G=1.421413741,W=-1.453152027,B=1.061405429;function L(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}const q=/->/g;function j(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(q,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,o]=e.split("->");(0,i.a)(-1===r.indexOf("..."),(()=>'The ellipsis notation ("...") is not supported yet.'));const s=r.split(","),a=s.length;if(t!==a)throw new Error(`Expected ${a} input tensors, received ${t}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const l=[];for(let e=0;e<o.length;++e){const t=o[e];if(!s.some((e=>-1!==e.indexOf(t))))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===l.indexOf(t)&&l.push(t)}for(let e=0;e<r.length;++e){const t=r[e];-1===l.indexOf(t)&&","!==t&&l.push(t)}const u=new Array(s.length);for(let e=0;e<a;++e){if(new Set(s[e].split("")).size!==s[e].length)throw new Error(`Found duplicate axes in input component ${s[e]}. Support for duplicate axes in input is not implemented yet.`);u[e]=[];for(let t=0;t<s[e].length;++t)u[e].push(l.indexOf(s[e][t]))}const h=l.length,c=[];for(let e=o.length;e<h;++e)c.push(e);return{allDims:l,summedDims:c,idDims:u}}function H(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;const r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function V(e,t,n){const r=new Array(e);for(let e=0;e<n.length;++e){const o=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=o[n]:(0,i.a)(r[t[e][n]]===o[n],(()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(o)}, but got dimension ${o[n]}`))}}function J(e,t){const n=e,r=[];let i=0;0===e.length&&n.push(-1),i=e.length+1;for(let e=0;e<i;++e)r.push([]);const o=[];for(let e=0;e<n.length;++e){const i=Z(t,n[e]);for(const t of i)-1===o.indexOf(t)&&(r[e].push(t),o.push(t))}return{path:n,steps:r}}function X(e){return e.every(((e,t)=>e===t))}function Z(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function K(e,t,n=0){let r=[];if("number"==typeof t)(0,i.a)(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const o=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);(0,i.a)(o<=1,(()=>"There should be only one negative value in split array."));const s=t.indexOf(-1);if(-1!==s){const r=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-r}(0,i.a)(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function Q(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function Y(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function ee(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function te(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function ne(e,t){return`size ${e} must be non-negative, not ${t}`}function re(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function ie(e,t){return`Input to reshape is a SparseTensor with ${(0,i.m)(e)}\n  dense values, but the requested shape requires a multiple of ${(0,i.m)(t)}. inputShape=${e} outputShape= ${t}`}function oe(e,t){return`Input to reshape is a tensor with ${(0,i.m)(e)} dense values, but the requested shape has ${(0,i.m)(t)}. inputShape=${e} outputShape=${t}`}function se(){return"segment ids must be >= 0"}function ae(){return"segment ids are not increasing"}function le(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function ue(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function he(e,t){let n,r=!1;for(e<=30?(n=e,r=!0):n=(0,i.N)(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=(0,i.N)(e,n+1);return n}function ce(e,t,n){const r=[],i=e.length;for(let o=0;o<i;o++)o!==t?r.push(e[o]):r.push(n);return r}function fe(e,t,n,r){const i=t.shape.length,o=e.shape.length;if(0!==r&&(r<-i||r>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);if(r<0&&(r+=i),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const s=e.shape[n],a=[];let l=1,u=1,h=1;for(let t=0;t<r;++t)a.push(e.shape[t]),l*=e.shape[t];for(let t=r;t<n;t++)a.push(e.shape[t]),u*=e.shape[t];for(let e=r;e<i;e++)a.push(t.shape[e]);for(let t=n+1;t<o;t++)a.push(e.shape[t]),h*=e.shape[t];return{batchSize:l,sliceSize:h,outerSize:u,dimSize:s,outputShape:a}}var pe=Object.freeze({__proto__:null,segOpComputeOptimalWindowSize:he,computeOutShape:ce,collectGatherOpShapeInfo:fe});function de(e){try{return e.map((e=>(0,r.cd)(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function ge(e){return e.map((e=>(0,r.c7)(e)))}var me=Object.freeze({__proto__:null,slice_util:x,segment_util:pe,fromUint8ToStringArray:de,fromStringArrayToUint8:ge,upcastType:r.c6,axesAreInnerMostDims:r.c$,combineLocations:r.d0,computeOutAndReduceShapes:r.c5,expandShapeToKeepDim:r.aP,assertAxesAreInnerMostDims:r.cp,getAxesPermutation:r.cn,getUndoAxesPermutation:r.cB,getInnerMostAxes:r.co,getBroadcastDims:r.c3,getReductionAxes:r.d1,assertAndGetBroadcastShape:r.an,assertParamsConsistent:v,computeOutShape:I,computeDilation2DInfo:r.cD,computePool2DInfo:r.cs,computePool3DInfo:r.ct,computeConv2DInfo:r.bC,computeConv3DInfo:r.cy,computeDefaultPad:r.d2,tupleValuesAreOne:r.bF,eitherStridesOrDilationsAreOne:r._,convertConv2DDataFormat:r.cx,checkPadOnDimRoundingMode:r.$,getFusedDyActivation:r.bE,getFusedBiasGradient:r.bG,applyActivation:r.bB,shouldFuse:r.bA,PARALLELIZE_THRESHOLD:30,computeOptimalWindowSize:F,getImageCenter:k,getReshaped:D,getPermuted:O,getReshapedPermuted:R,getSliceBeginCoords:N,getSliceSize:_,prepareAndValidate:u,validateUpdateShape:r.d3,validateInput:r.bv,calculateShapes:r.cP,SELU_SCALEALPHA:T,SELU_SCALE:z,ERF_P:U,ERF_A1:P,ERF_A2:C,ERF_A3:G,ERF_A4:W,ERF_A5:B,warn:r.ce,log:r.d4,mergeRealAndImagArrays:L,splitRealAndImagArrays:function(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}},complexWithEvenIndex:function(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}},complexWithOddIndex:function(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}},getComplexWithIndex:function(e,t){return{real:e[2*t],imag:e[2*t+1]}},assignToTypedArray:function(e,t,n,r){e[2*r]=t,e[2*r+1]=n},exponents:function(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let i=0;i<Math.ceil(e/2);i++){const o=(t?2:-2)*Math.PI*(i/e);n[i]=Math.cos(o),r[i]=Math.sin(o)}return{real:n,imag:r}},exponent:function(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}},decodeEinsumEquation:j,getEinsumPermutation:H,checkEinsumDimSizes:V,getEinsumComputePath:J,isIdentityPermutation:X,prepareSplitSize:K,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Q,getSparseFillEmptyRowsNegativeIndexErrorMessage:Y,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:ee,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:te,getSparseReshapeNegativeOutputDimErrorMessage:ne,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:re,getSparseReshapeInputOutputMultipleErrorMessage:ie,getSparseReshapeInputOutputMismatchErrorMessage:oe,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:se,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:ae,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:le,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:ue})},5912:(e,t,n)=>{function r(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,a(e,t,n)}function i(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,a(e,n,r),a(t,n,r)}function o(e,t,n){return Math.max(e,Math.min(t,n))}function s(e){return e%2==0?e:e+1}function a(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function l(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function u(e,t){const n=Math.random();return t*n+(1-n)*e}function h(e,t){let n=0;for(let r=0;r<e.length;r++){const i=Number(e[r])-Number(t[r]);n+=i*i}return n}function c(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function f(e,t,n=""){c(w(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function p(e){c(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function d(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||R(e)&&!n)for(let r=0;r<e.length;++r)d(e[r],t,n);else t.push(e);return t}function g(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function m(e){return 0===e.length}function w(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function y(e){return e%1==0}function b(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function A(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function E(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return r(t),t}function S(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function $(e,t=(e=>0),n){return new Promise(((r,i)=>{let o=0;const s=()=>{if(e())return void r();o++;const a=t(o);null!=n&&o>=n?i():setTimeout(s,a)};s()}))}function M(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const i=e.slice();return i[r]=t/n,i}function x(e,t){const n=t.length;return c((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),c(e.every((e=>y(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function v(e,t){const n=[],r=[],i=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||i?null:x(t,e).sort();let s=0;for(let t=0;t<e.length;++t){if(null!=o){if(o[s]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==o[s]||o[s]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),o[s]<=t&&s++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function I(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function F(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function k(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function D(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function O(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function R(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function N(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function _(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function T(e){return"string"==typeof e||e instanceof String}function z(e){return"boolean"==typeof e}function U(e){return"number"==typeof e}function P(e){return Array.isArray(e)?P(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":U(e)?"float32":T(e)?"string":z(e)?"bool":"float32"}function C(e){return!!(e&&e.constructor&&e.call&&e.apply)}function G(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function W(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function B(e,t,n,r=!1){const i=new Array;if(1===t.length){const o=t[0]*(r?2:1);for(let t=0;t<o;t++)i[t]=n[e+t]}else{const o=t[0],s=t.slice(1),a=s.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<o;t++)i[t]=B(e+t*a,s,n,r)}return i}function L(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return B(0,e,t,n)}function q(e,t){const n=j(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function j(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function H(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return L(e,new Float32Array(n));if("int32"===t)return L(e,new Int32Array(n));if("bool"===t)return L(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function V(e){e.forEach((t=>{c(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function J(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function X(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function Z(e){return e&&e.then&&"function"==typeof e.then}n.d(t,{A:()=>v,B:()=>I,C:()=>F,D:()=>D,E:()=>O,F:()=>R,G:()=>N,H:()=>_,I:()=>T,J:()=>z,K:()=>U,L:()=>P,M:()=>C,N:()=>G,O:()=>W,P:()=>q,Q:()=>j,R:()=>H,S:()=>V,T:()=>J,U:()=>X,a:()=>c,b:()=>w,c:()=>k,d:()=>i,e:()=>o,f:()=>d,g:()=>a,h:()=>l,i:()=>Z,j:()=>h,k:()=>f,l:()=>p,m:()=>g,n:()=>s,o:()=>m,p:()=>y,q:()=>b,r:()=>u,s:()=>r,t:()=>L,u:()=>A,v:()=>E,w:()=>S,x:()=>$,y:()=>M,z:()=>x}),n(5389),n(3807)},6018:(e,t,n)=>{var r=n(2692),i=(n(1026),n(8399)),o=n(1260),s=n(5912);let a;const l=640;let u,h,c=["red","white"];const f=e=>(500-e)/500;!async function(){await r.CQI("webgl");let e=i.o.MediaPipeHands;const t=await i.c(e,{runtime:"tfjs",modelType:"lite"});let n;try{n=await async function(){const e=await async function(){if(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new Error("Browser API navigator.mediaDevices.getUserMedia not available");const e=document.getElementById("video"),t=await navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"user"}});return e.srcObject=t,new Promise((t=>{e.onloadedmetadata=()=>{t(e)}}))}();return e.play(),e}()}catch(e){throw document.getElementById("info").style.display="block",e}n.width=n.videoWidth,n.height=n.videoHeight,u=document.getElementById("canvas"),u.height=n.videoHeight,u.width=n.videoWidth,h=u.getContext("2d");const p=Array(2),d=Array(2),g=Array(2),m=Array(2);for(const e of[0,1])if(p[e]=new o.S9(0).toDestination(),m[e]=new o.fL(0).connect(p[e]),1===e)d[e]=(new o.nu).connect(m[e]).start(),g[e]=new o.MZ({value:440,units:"hertz"}).connect(d[e].frequency);else{const t=new o.lW("../grain.wav",(()=>{console.log("buffer loaded"),d[e]=new o.pw(t),d[e].loop=!0,d[e].loopEnd=1,d[e].connect(m[e]).start(),g[e]=new o.MZ({value:440,units:"hertz"})}))}(async(e,t,n,r,i,p)=>{!async function d(){const g=await t.estimateHands(e);if(h=u.getContext("2d"),h.clearRect(0,0,u.width,u.height),g.length>0){(0,o.zO)();for(const e in g){const t=parseInt(e),o=g[t].keypoints,a=o[0].x,u=o[0].y;if(a&&u){const e=(0,s.e)(-1,(l-o[0].x)/l*2-1,1);let u=(m=a,Math.max(1e4*(l-m)/l,0)**.5);0==t?(p[t].grainSize=(0,s.e)(.05,.3*(1.2-e),2),p[t].detune=120*e,p[t].playbackRate=(0,s.e)(.5,.5+4*(1.1-e),10),n[t].gain.rampTo(4*f(o[0].y),.1)):(r[t].rampTo(u,.05),n[t].gain.rampTo(.1*f(o[0].y),.1)),i[t].pan.rampTo(e)}}for(const e in g)for(const t of Array(20).keys()){h.strokeStyle=c[parseInt(e)%2],h.beginPath();const n=g[e].keypoints[t],r=g[e].keypoints[t+1];h.moveTo(n.x,n.y),h.lineTo(r.x,r.y),h.stroke()}}else{h=u.getContext("2d"),h.clearRect(0,0,u.width,u.height);for(const e of n)e?.gain.rampTo(0,.25)}var m;a=requestAnimationFrame(d)}()})(n,t,p,g,m,d)}()}},e=>{e.O(0,[675,202,615,928,955,572,143],(()=>(6018,e(e.s=6018)))),e.O()}]);