/*! For license information please see lib-fused_util-14ebb22b.707b112968862f76ff92.js.LICENSE.txt */
"use strict";(self.webpackChunktheremin=self.webpackChunktheremin||[]).push([[589],{198:(t,e,n)=>{n.d(e,{$:()=>it,A:()=>U,B:()=>st,C:()=>dt,D:()=>H,E:()=>zr,F:()=>zt,G:()=>G,H:()=>W,I:()=>q,J:()=>Z,K:()=>Q,L:()=>J,M:()=>Y,N:()=>X,O:()=>Ne,P:()=>vs,Q:()=>$s,R:()=>At,S:()=>tt,T:()=>xr,U:()=>nt,V:()=>Qr,W:()=>ft,X:()=>en,Y:()=>xn,Z:()=>at,_:()=>Ht,a:()=>rs,a$:()=>Ke,a0:()=>ot,a1:()=>Sn,a2:()=>ct,a3:()=>ut,a4:()=>pt,a5:()=>mt,a6:()=>yt,a7:()=>wt,a8:()=>It,a9:()=>vt,aA:()=>Sr,aB:()=>Se,aC:()=>on,aD:()=>fe,aE:()=>$n,aF:()=>Ns,aG:()=>le,aH:()=>ce,aI:()=>ue,aJ:()=>ge,aK:()=>ye,aL:()=>ke,aM:()=>pe,aN:()=>we,aO:()=>Ie,aP:()=>ve,aQ:()=>Te,aR:()=>$e,aS:()=>Ee,aT:()=>Fe,aU:()=>Me,aV:()=>Ce,aW:()=>un,aX:()=>Pe,aY:()=>_e,aZ:()=>Oe,a_:()=>Ve,aa:()=>$t,ab:()=>Et,ac:()=>xt,ad:()=>Bt,ae:()=>is,af:()=>Pt,ag:()=>Ye,ah:()=>Rn,ai:()=>Mt,aj:()=>Ct,ak:()=>Lt,al:()=>_t,am:()=>Ot,an:()=>Kt,ao:()=>Ut,ap:()=>Gt,aq:()=>qt,ar:()=>Zt,as:()=>Xt,at:()=>ee,au:()=>re,av:()=>se,aw:()=>ae,ax:()=>he,ay:()=>ie,az:()=>oe,b:()=>Vs,b$:()=>fr,b0:()=>Ze,b1:()=>Qe,b2:()=>Je,b3:()=>tn,b4:()=>vr,b5:()=>sn,b6:()=>nn,b7:()=>rn,b8:()=>dn,b9:()=>Vt,bA:()=>Vn,bB:()=>_n,bC:()=>Tt,bD:()=>jt,bE:()=>Ln,bF:()=>De,bG:()=>Ae,bH:()=>Be,bI:()=>Ge,bJ:()=>ze,bK:()=>Dn,bL:()=>fn,bM:()=>pn,bN:()=>gn,bO:()=>mn,bP:()=>In,bQ:()=>vn,bR:()=>Tn,bS:()=>_r,bT:()=>Hn,bU:()=>Pn,bV:()=>ss,bW:()=>cr,bX:()=>Ms,bY:()=>Rr,bZ:()=>dr,b_:()=>lr,ba:()=>Jt,bb:()=>hn,bc:()=>ln,bd:()=>bn,be:()=>Re,bf:()=>wn,bg:()=>En,bh:()=>Gr,bi:()=>Yr,bj:()=>Fn,bk:()=>An,bl:()=>Mn,bm:()=>ls,bn:()=>Xe,bo:()=>yn,bp:()=>Wt,bq:()=>gt,br:()=>Hs,bs:()=>zs,bt:()=>ps,bu:()=>On,bv:()=>js,bw:()=>Is,bx:()=>Us,by:()=>St,bz:()=>Ft,c:()=>ns,c0:()=>Bs,c1:()=>As,c2:()=>Rs,c3:()=>Cs,c4:()=>Ps,c5:()=>Ls,c6:()=>as,c7:()=>hs,c8:()=>ds,c9:()=>fs,cA:()=>Yt,cB:()=>te,cC:()=>de,cD:()=>be,cE:()=>me,cF:()=>je,cG:()=>qe,cH:()=>We,cI:()=>He,cJ:()=>an,cK:()=>kn,cL:()=>Cn,cM:()=>Nn,cN:()=>qn,cO:()=>Lr,ca:()=>gs,cb:()=>ms,cc:()=>Ts,cd:()=>os,ce:()=>cs,cf:()=>Kn,cg:()=>jn,ch:()=>i,ci:()=>a,cj:()=>hr,ck:()=>Qt,cl:()=>ht,cm:()=>ne,cn:()=>Le,co:()=>xe,cp:()=>Ue,cq:()=>Cr,cr:()=>cn,cs:()=>rt,ct:()=>et,cu:()=>lt,cv:()=>bt,cw:()=>kt,cx:()=>Dt,cy:()=>Nt,cz:()=>Rt,d:()=>Os,e:()=>u,f:()=>Ss,g:()=>Xr,h:()=>Ds,i:()=>P,j:()=>Ur,k:()=>Er,l:()=>Fs,m:()=>us,n:()=>es,o:()=>Jr,p:()=>_s,q:()=>Zr,r:()=>Es,s:()=>xs,t:()=>ts,u:()=>Pr,v:()=>Bn,w:()=>V,x:()=>K,y:()=>j,z:()=>z}),n(5389),n(3807);var r=n(3077),s=n(3801);class a{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class i{refCount(t){return o("refCount")}incRef(t){return o("incRef")}timerAvailable(){return!0}time(t){return o("time")}read(t){return o("read")}readSync(t){return o("readSync")}readToGPU(t,e){return o("readToGPU")}numDataIds(){return o("numDataIds")}disposeData(t,e){return o("disposeData")}write(t,e,n){return o("write")}move(t,e,n,r,s){return o("move")}memory(){return o("memory")}floatPrecision(){return o("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return o("dispose")}}function o(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}class l{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=c,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(u().getBool("IS_TEST")||u().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];u().getBool("IS_TEST")||u().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if((0,r.i)(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)}))}}function c(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")))),e}function u(){return h}let h=null;function d(){throw new Error("setTimeout has not been defined")}function f(){throw new Error("clearTimeout has not been defined")}var p,g=d,m=f;function y(t){if(g===setTimeout)return setTimeout(t,0);if((g===d||!g)&&setTimeout)return g=setTimeout,setTimeout(t,0);try{return g(t,0)}catch(e){try{return g.call(null,t,0)}catch(e){return g.call(this,t,0)}}}"function"==typeof(p="undefined"!=typeof window?window:"undefined"!=typeof self?self:{}).setTimeout&&(g=setTimeout),"function"==typeof p.clearTimeout&&(m=clearTimeout);var b,k=[],w=!1,I=-1;function v(){w&&b&&(w=!1,b.length?k=b.concat(k):I=-1,k.length&&T())}function T(){if(!w){var t=y(v);w=!0;for(var e=k.length;e;){for(b=k,k=[];++I<e;)b&&b[I].run();I=-1,e=k.length}b=null,w=!1,function(t){if(m===clearTimeout)return clearTimeout(t);if((m===f||!m)&&clearTimeout)return m=clearTimeout,clearTimeout(t);try{m(t)}catch(e){try{return m.call(null,t)}catch(e){return m.call(this,t)}}}(t)}}function $(t,e){this.fun=t,this.array=e}function E(){}$.prototype.run=function(){this.fun.apply(null,this.array)};var x=E,S=E,F=E,D=E,B=E,A=E,M=E,N=p.performance||{},R=N.now||N.mozNow||N.msNow||N.oNow||N.webkitNow||function(){return(new Date).getTime()},C=new Date,P={nextTick:function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];k.push(new $(t,e)),1!==k.length||w||y(T)},title:"browser",browser:!0,env:{NODE_ENV:"production"},argv:[],version:"",versions:{},on:x,addListener:S,once:F,off:D,removeListener:B,removeAllListeners:A,emit:M,binding:function(t){throw new Error("process.binding is not supported")},cwd:function(){return"/"},chdir:function(t){throw new Error("process.chdir is not supported")},umask:function(){return 0},hrtime:function(t){var e=.001*R.call(N),n=Math.floor(e),r=Math.floor(e%1*1e9);return t&&(n-=t[0],(r-=t[1])<0&&(n--,r+=1e9)),[n,r]},platform:"browser",release:{},config:{},uptime:function(){return(new Date-C)/1e3}};let L;function _(){if(null==L){let t;if("undefined"!=typeof window)t=window;else if(void 0!==n.g)t=n.g;else if(void 0!==P)t=P;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}L=t}return L}function O(t,e){const n=function(){const t=_();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const V="Abs",K="Acos",j="Acosh",U="Add",z="AddN",H="All",G="Any",W="ArgMax",q="ArgMin",Z="Asin",Q="Asinh",J="Atan",X="Atanh",Y="Atan2",tt="AvgPool",et="AvgPoolGrad",nt="AvgPool3D",rt="AvgPool3DGrad",st="BatchMatMul",at="BatchToSpaceND",it="Bincount",ot="BroadcastArgs",lt="Cast",ct="Ceil",ut="ClipByValue",ht="Complex",dt="ComplexAbs",ft="Concat",pt="Conv2D",gt="Conv2DBackpropFilter",mt="Conv2DBackpropInput",yt="Conv3D",bt="Conv3DBackpropFilterV2",kt="Conv3DBackpropInputV2",wt="Cos",It="Cosh",vt="Cumsum",Tt="CropAndResize",$t="DenseBincount",Et="DepthToSpace",xt="DepthwiseConv2dNative",St="DepthwiseConv2dNativeBackpropFilter",Ft="DepthwiseConv2dNativeBackpropInput",Dt="Diag",Bt="Dilation2D",At="RealDiv",Mt="Einsum",Nt="Elu",Rt="EluGrad",Ct="Erf",Pt="Equal",Lt="Exp",_t="ExpandDims",Ot="Expm1",Vt="FFT",Kt="Fill",jt="FlipLeftRight",Ut="Floor",zt="FloorDiv",Ht="FusedBatchNorm",Gt="GatherV2",Wt="GatherNd",qt="Greater",Zt="GreaterEqual",Qt="Identity",Jt="IFFT",Xt="Imag",Yt="IsFinite",te="IsInf",ee="IsNan",ne="LeakyRelu",re="Less",se="LessEqual",ae="LinSpace",ie="Log",oe="Log1p",le="LogicalAnd",ce="LogicalNot",ue="LogicalOr",he="LRN",de="LRNGrad",fe="Max",pe="Maximum",ge="MaxPool",me="MaxPoolGrad",ye="MaxPool3D",be="MaxPool3DGrad",ke="MaxPoolWithArgmax",we="Mean",Ie="Min",ve="Minimum",Te="MirrorPad",$e="Mod",Ee="Multinomial",xe="Multiply",Se="Neg",Fe="NotEqual",De="NonMaxSuppressionV3",Be="NonMaxSuppressionV4",Ae="NonMaxSuppressionV5",Me="OnesLike",Ne="OneHot",Re="Pack",Ce="PadV2",Pe="Pow",Le="Prelu",_e="Prod",Oe="Range",Ve="Real",Ke="Reciprocal",je="Relu",Ue="Reshape",ze="ResizeNearestNeighbor",He="ResizeNearestNeighborGrad",Ge="ResizeBilinear",We="ResizeBilinearGrad",qe="Relu6",Ze="Reverse",Qe="Round",Je="Rsqrt",Xe="ScatterNd",Ye="Select",tn="Selu",en="Slice",nn="Sin",rn="Sinh",sn="Sign",an="Sigmoid",on="Softplus",ln="Sqrt",cn="Sum",un="SpaceToBatchND",hn="SplitV",dn="Softmax",fn="SparseFillEmptyRows",pn="SparseReshape",gn="SparseSegmentMean",mn="SparseSegmentSum",yn="SparseToDense",bn="SquaredDifference",kn="Square",wn="StridedSlice",In="StringNGrams",vn="StringSplit",Tn="StringToHashBucketFast",$n="Sub",En="Tan",xn="Tanh",Sn="Tile",Fn="TopK",Dn="Transform",Bn="Transpose",An="Unique",Mn="Unpack",Nn="UnsortedSegmentSum",Rn="ZerosLike",Cn="Step",Pn="FromPixels",Ln="RotateWithOffset",_n="_FusedMatMul",On="FusedConv2D",Vn="FusedDepthwiseConv2D";function Kn(...t){u().getBool("IS_TEST")||u().getBool("PROD")||console.warn(...t)}function jn(...t){u().getBool("IS_TEST")||u().getBool("PROD")||console.log(...t)}const Un=O("kernelRegistry",(()=>new Map)),zn=O("gradRegistry",(()=>new Map));function Hn(t,e){const n=Zn(t,e);return Un.get(n)}function Gn(t){return zn.get(t)}function Wn(t){const e=Un.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===t&&n.push(i)}return n}function qn(t){const{kernelName:e,backendName:n}=t,r=Zn(e,n);Un.has(r)&&Kn(`The kernel '${e}' for backend '${n}' is already registered`),Un.set(r,t)}function Zn(t,e){return`${e}_${t}`}const Qn=s.l||s.L;function Jn(t){return Qn.fromString(t,!0,16)}const Xn=Jn("c3a5c85c97cb3127"),Yn=Jn("b492b66fbe98f273"),tr=Jn("9ae16a3b2f90404f");function er(t){return t.xor(t.shru(47))}function nr(t,e,n){const r=t.slice(e,e+n);return Qn.fromBytes(Array.from(r),!0,!0)}function rr(t,e){return nr(t,e,8)}function sr(t,e){return nr(t,e,4)}function ar(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function ir(t,e,n=Jn("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function or(t,e,n,r){return function(t,e,n,r,s,a){s=s.add(t),a=ar(a.add(s).add(r),21);const i=s;return s=(s=s.add(e)).add(n),a=a.add(ar(s,44)),[s.add(r),a.add(i)]}(rr(t,e),rr(t,e+8),rr(t,e+16),rr(t,e+24),n,r)}function lr(t,e=t.length){const n=Qn.fromNumber(81,!0);if(e<=32)return e<=16?function(t,e=t.length){if(e>=8){const n=tr.add(2*e),r=rr(t,0).add(tr),s=rr(t,e-8);return ir(ar(s,37).mul(n).add(r),ar(r,25).add(s).mul(n),n)}if(e>=4){const n=tr.add(2*e);return ir(sr(t,0).shl(3).add(e),sr(t,e-4),n)}if(e>0){const n=t[0]+(t[e>>1]<<8),r=e+(t[e-1]<<2);return er(tr.mul(n).xor(Xn.mul(r))).mul(tr)}return tr}(t,e):function(t,e=t.length){const n=tr.add(2*e),r=rr(t,0).mul(Yn),s=rr(t,8),a=rr(t,e-8).mul(n),i=rr(t,e-16).mul(tr);return ir(ar(r.add(s),43).add(ar(a,30)).add(i),r.add(ar(s.add(tr),18)).add(a),n)}(t,e);if(e<=64)return function(t,e=t.length){const n=tr.add(2*e),r=rr(t,0).mul(tr),s=rr(t,8),a=rr(t,e-8).mul(n),i=rr(t,e-16).mul(tr),o=ar(r.add(s),43).add(ar(a,30)).add(i),l=ir(o,r.add(ar(s.add(tr),18)).add(a),n),c=rr(t,16).mul(n),u=rr(t,24),h=o.add(rr(t,e-32)).mul(n),d=l.add(rr(t,e-24)).mul(n);return ir(ar(c.add(u),43).add(ar(h,30)).add(d),c.add(ar(u.add(r),18)).add(h),n)}(t,e);let r=n,s=n.mul(Yn).add(113),a=er(s.mul(tr).add(113)).mul(tr),i=[Qn.UZERO,Qn.UZERO],o=[Qn.UZERO,Qn.UZERO];r=r.mul(tr).add(rr(t,0));let l=0;const c=64*(e-1>>6),u=c+(e-1&63)-63;do{r=ar(r.add(s).add(i[0]).add(rr(t,l+8)),37).mul(Yn),s=ar(s.add(i[1]).add(rr(t,l+48)),42).mul(Yn),r=r.xor(o[1]),s=s.add(i[0]).add(rr(t,l+40)),a=ar(a.add(o[0]),33).mul(Yn),i=or(t,l,i[1].mul(Yn),r.add(o[0])),o=or(t,l+32,a.add(o[1]),s.add(rr(t,l+16))),[a,r]=[r,a],l+=64}while(l!==c);const h=Yn.add(a.and(255).shl(1));return l=u,o[0]=o[0].add(e-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=ar(r.add(s).add(i[0]).add(rr(t,l+8)),37).mul(h),s=ar(s.add(i[1]).add(rr(t,l+48)),42).mul(h),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(rr(t,l+40))),a=ar(a.add(o[0]),33).mul(h),i=or(t,l,i[1].mul(h),r.add(o[0])),o=or(t,l+32,a.add(o[1]),s.add(rr(t,l+16))),[a,r]=[r,a],ir(ir(i[0],o[0],h).add(er(s).mul(Xn)).add(a),ir(i[1],o[1],h).add(r),h)}function cr(t,e){return"string"===e?dr(t):ur([t],e)}function ur(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=(0,r.h)(t)),u().getBool("DEBUG")&&(0,r.j)(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function hr(){return u().platform.now()}function dr(t,e="utf-8"){return e=e||"utf-8",u().platform.encode(t,e)}function fr(t,e="utf-8"){return e=e||"utf-8",u().platform.decode(t,e)}r.k,r.l,r.n,r.o,r.q,r.r,r.u,r.v,r.a,r.e,r.g,r.h,r.s,r.w,r.b,r.c,r.x,r.y,r.z,r.A,r.B,r.C,r.p,r.f,r.D,r.E,r.j,r.F,r.G,r.H,r.I,r.J,r.K,r.L,r.M,r.N,r.d,r.O,r.P,r.t,r.m,r.Q,r.R,r.S,r.T,r.U,r.i;class pr{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new mr)}profileKernel(t,e,n){let r;const s=()=>{r=n()};let a;const i=hr();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const t of r)t.dataSync();a=Promise.resolve({kernelMs:hr()-i})}if(u().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let e=0;e<r.length;e++){const n=r[e];n.data().then((e=>{gr(e,n.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:a.then((t=>t.kernelMs)),extraInfo:a.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:s,extraInfo:a}=t;n.forEach((t=>{Promise.all([t.data(),r,a]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],s,n[2])}))}))}}function gr(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class mr{logKernelProfile(t,e,n,s,a,i){const o="number"==typeof s?(0,r.A)(`${s}ms`,9):s.error,l=(0,r.A)(t,25),c=e.rank,u=e.size,h=(0,r.A)(e.shape.toString(),14);let d="";for(const t in a){const n=a[t];if(null!=n){const r=n.shape||e.shape,s=r.length;d+=`${t}: ${s}D ${s>0?r:""} `}}console.log(`%c${l}\t%c${o}\t%c${c}D ${h}\t%c${u}\t%c${d}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function yr(t,e,n,s){const a=(0,r.P)(e),i=function(t,e,n,s){const a=(0,r.s)(e),i=s[s.length-1],o=new Array(i).fill(0),l=e.length,c="complex64"===n?Ir(t):t;if(l>1)for(let t=0;t<a/i;t++){const e=t*i;for(let t=0;t<i;t++)o[t]=Math.max(o[t],br(c[e+t],0,n).length)}return o}(t,e,n,a),o=e.length,l=wr(t,e,n,a,i),c=["Tensor"];return s&&(c.push(`  dtype: ${n}`),c.push(`  rank: ${o}`),c.push(`  shape: [${e}]`),c.push("  values:")),c.push(l.map((t=>"    "+t)).join("\n")),c.join("\n")}function br(t,e,n){let s;return s=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:(0,r.K)(t)?`'${t}'`:"bool"===n?kr(t):parseFloat(t.toFixed(7)).toString(),(0,r.A)(s,e)}function kr(t){return 0===t?"false":"true"}function wr(t,e,n,r,s,a=!0){const i="complex64"===n?2:1,o=e[0],l=e.length;if(0===l)return"complex64"===n?[br(Ir(t)[0],0,n)]:"bool"===n?[kr(t[0])]:[t[0].toString()];if(1===l){if(o>20){const e=3*i;let r=Array.from(t.slice(0,e)),a=Array.from(t.slice((o-3)*i,o*i));return"complex64"===n&&(r=Ir(r),a=Ir(a)),["["+r.map(((t,e)=>br(t,s[e],n))).join(", ")+", ..., "+a.map(((t,e)=>br(t,s[o-3+e],n))).join(", ")+"]"]}return["["+("complex64"===n?Ir(t):Array.from(t)).map(((t,e)=>br(t,s[e],n))).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*i,d=[];if(o>20){for(let e=0;e<3;e++){const r=e*h,a=r+h;d.push(...wr(t.slice(r,a),c,n,u,s,!1))}d.push("...");for(let e=o-3;e<o;e++){const r=e*h,a=r+h;d.push(...wr(t.slice(r,a),c,n,u,s,e===o-1))}}else for(let e=0;e<o;e++){const r=e*h,a=r+h;d.push(...wr(t.slice(r,a),c,n,u,s,e===o-1))}const f=2===l?",":"";d[0]="["+d[0]+f;for(let t=1;t<d.length-1;t++)d[t]=" "+d[t]+f;let p=",\n";for(let t=2;t<l;t++)p+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":p),d}function Ir(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class vr{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=(0,r.s)(t),null!=n){const t=n.length;(0,r.a)(t===this.size,(()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||(0,r.E)(e,this.size),this.strides=(0,r.P)(t)}set(t,...e){0===e.length&&(e=[0]),(0,r.a)(e.length===this.rank,(()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`));const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const n of t){if(n<0||n>=this.shape[e]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}e++}let n=t[t.length-1];for(let e=0;e<t.length-1;++e)n+=this.strides[e]*t[e];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Tr().makeTensor(this.values,this.shape,this.dtype)}}let Tr=null,$r=null;function Er(t){$r=t}class xr{constructor(t,e,n,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=(0,r.s)(t),this.strides=(0,r.P)(t),this.dataId=n,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return $r.buffer(this.shape,this.dtype,t)}bufferSync(){return $r.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return(0,r.t)(this.shape,t,"complex64"===this.dtype)}arraySync(){return(0,r.t)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Tr().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map((t=>fr(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Tr().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Tr().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>fr(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Tr().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Tr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return $r.print(this,t)}clone(){return this.throwIfDisposed(),$r.clone(this)}toString(t=!1){return yr(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),$r.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Tr().makeVariable(this,t,e,n)}}Object.defineProperty(xr,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),O("Tensor",(()=>xr));class Sr extends xr{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!(0,r.b)(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Tr().disposeTensor(this),this.dataId=t.dataId,Tr().incRef(this,null)}dispose(){Tr().disposeVariable(this),this.isDisposedInternal=!0}}var Fr,Dr,Br,Ar,Mr;Object.defineProperty(Sr,Symbol.hasInstance,{value:t=>t instanceof xr&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Fr||(Fr={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Dr||(Dr={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Br||(Br={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(Ar||(Ar={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Mr||(Mr={}));const Nr={float32:Ar,int32:Dr,bool:Br,complex64:Mr};function Rr(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Nr[t][e]}function Cr(t){return Rr(t,"int32")}function Pr(t,e){if(t.dtype===e.dtype)return[t,e];const n=Rr(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Lr(t,e){(0,r.a)(t.dtype===e.dtype,(()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`))}function _r(t){const e=[];return Or(t,e,new Set),e}function Or(t,e,n){if(null==t)return;if(t instanceof xr)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=t;for(const t in s){const r=s[t];n.has(r)||(n.add(r),Or(r,e,n))}}function Vr(t){return null!=t.kernelName}class Kr{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class jr{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Kr}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(Kn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new pr(this.backendInstance),!0}setupRegisteredKernels(){Wn(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){Wn(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof i||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0)))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,Kn(`Initialization of backend ${t} failed`),Kn(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return Kn(`Initialization of backend ${t} failed`),Kn(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,s=this.readSync(e),a=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return jr.nextTensorId++}nextVariableId(){return jr.nextVariableId++}clone(t){const e=zr.runKernel(Qt,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t};return zr.runKernel(lt,e,{dtype:"float32"})}})),[],{}),e}runKernel(t,e,n){if(null==this.backendName&&this.backend,null==Hn(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let s=0;n.forEach((t=>{s+="complex64"===t.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-e-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const s=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;let o,l;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=Vr(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Vr(t)){const{kernelName:e,inputs:a,attrs:i}=t;null==this.backendName&&this.backend;const c=Hn(e,this.backendName);(0,r.a)(null!=c,(()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`)),o=()=>{const t=this.backend.numDataIds();l=c.kernelFunc({inputs:a,attrs:i,backend:this.backend});const r=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,r);const o=r.map((t=>{if(null!=t.rank)return t;const{dataId:e,shape:n,dtype:r}=t;return this.makeTensorFromDataId(e,n,r)}));if(s){const t=this.getTensorsForGradient(e,a,o);n=this.saveTensorsForBackwardMode(t)}return o}}else{const{forwardFunc:e}=t,r=t=>{s&&(n=t.map((t=>this.keep(this.clone(t)))))};o=()=>{const t=this.backend.numDataIds();l=this.tidy((()=>e(this.backend,r)));const n=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,t,n),n}}const{inputs:u,attrs:h}=t,d=Vr(t)?null:t.backwardsFunc;let f;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(c,u,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),e=f.outputs):e=o()})),s&&this.addTapeNode(c,u,e,d,n,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((t=>null!=u[t]?u[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?e:e[0]}saveTensorsForBackwardMode(t){const e=t.map((t=>this.keep(this.clone(t))));return e}getTensorsForGradient(t,e,n){const s=Gn(t);if(null!=s){const t=s.inputsToSave||[],a=s.outputsToSave||[];let i;s.saveAllInputs?((0,r.a)(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),i=Object.keys(e).map((t=>e[t]))):i=t.map((t=>e[t]));const o=n.filter(((t,e)=>a[e]));return i.concat(o)}return[]}makeTensor(t,e,n,s){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",s=s||this.backend;let a=t;"string"===n&&(0,r.K)(t[0])&&(a=t.map((t=>dr(t))));const i=s.write(a,e,n),o=new xr(e,n,i,this.nextTensorId());if(this.trackTensor(o,s),"string"===n){const t=this.state.tensorInfo.get(i),e=(0,r.J)(a);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,r){const s=new xr(e,n=n||"float32",t,this.nextTensorId());return this.trackTensor(s,r),s}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const s=new Sr(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*(0,r.I)(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Sr||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*(0,r.I)(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,s,a,i){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:a},l=Gn(t);null!=l&&(s=l.gradFunc),null!=s&&(o.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],s=(0,r.Q)(t.size,t.dtype);return this.makeTensor(s,t.shape,t.dtype)}return t})),s(t.length>1?t:t[0],a,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=_r(t),n=new Set(e.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n,s=!1){if((0,r.a)(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));(0,r.a)(a instanceof xr,(()=>"The result y returned by f() must be a tensor."));const i=function(t,e,n){const r={},s={};for(let t=0;t<e.length;t++)r[e[t].id]=!0;for(let n=0;n<t.length;n++){const a=t[n],i=a.inputs;for(const t in i){const n=i[t];let o=!1;for(let t=0;t<e.length;t++)if(r[n.id]){a.outputs.forEach((t=>r[t.id]=!0)),o=!0,s[a.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let e=t.length-1;e>=0;e--){const n=t[e],r=n.inputs;for(let t=0;t<n.outputs.length;t++)if(a[n.outputs[t].id]){for(const t in r)a[r[t].id]=!0,i[n.id]=!0;break}}const o=[];for(let e=0;e<t.length;e++){const n=t[e];if(s[n.id]&&i[n.id]){const t={};for(const e in n.inputs){const s=n.inputs[e];r[s.id]&&(t[e]=s)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,o.push(e)}}return o}(this.state.activeTape,e,a);if(!s&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[a.id]=null==n?function(t){const e=(0,r.m)((0,r.s)(t),"float32");return zr.makeTensor(e,t,"float32")}(a.shape):n,function(t,e,n,s){for(let a=e.length-1;a>=0;a--){const i=e[a],o=[];if(i.outputs.forEach((e=>{const n=t[e.id];null!=n?o.push(n):o.push(null)})),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const l=i.gradient(o);for(const e in i.inputs){if(!(e in l))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(l)}.`);const a=n((()=>l[e]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${a.dtype}'`);const o=i.inputs[e];if(!(0,r.b)(a.shape,o.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${e}' has shape '${a.shape}', which does not match the shape of the input '${o.shape}'`);if(null==t[o.id])t[o.id]=a;else{const e=t[o.id];t[o.id]=s(e,a),e.dispose()}}}}(t,i,(t=>this.tidy(t)),Hr);const s=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:a,grads:s}}))}customGrad(t){return(0,r.a)((0,r.d)(t),(()=>"The f passed in customGrad(f) must be a function.")),(...e)=>{let n;(0,r.a)(e.every((t=>t instanceof xr)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const s={};return e.forEach(((t,e)=>{s[e]=t})),this.runKernelFunc({forwardFunc:(s,a)=>(n=t(...e,a),(0,r.a)(n.value instanceof xr,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),(0,r.a)((0,r.d)(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(t,s)=>{const a=n.gradFunc(t,s),i=Array.isArray(a)?a:[a];(0,r.a)(i.length===e.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),(0,r.a)(i.every((t=>t instanceof xr)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return i.forEach(((t,e)=>{o[e]=()=>t})),o},inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=hr(),n=await this.backend.time(t);return n.wallMs=hr()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Kr;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Ur(){const t=_();if(null==t._tfengine){const e=new l(t);t._tfengine=new jr(e)}var e;return e=t._tfengine.ENV,h=e,Tr=()=>t._tfengine,t._tfengine}jr.nextTensorId=0,jr.nextVariableId=0;const zr=Ur();function Hr(t,e){const n={a:t,b:e};return zr.runKernel(U,n)}function Gr(t,e){let n=t;if((0,r.H)(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const s=[];for(;Array.isArray(n)||(0,r.H)(n)&&"string"!==e;)s.push(n.length),n=n[0];return Array.isArray(t)&&u().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Wr(t,s,[]),s}function Wr(t,e,n){if(n=n||[],!Array.isArray(t)&&!(0,r.H)(t))return void(0,r.a)(0===e.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));(0,r.a)(e.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),(0,r.a)(t.length===e[0],(()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const s=e.slice(1);for(let e=0;e<t.length;++e)Wr(t[e],s,n.concat(e))}function qr(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function Zr(t,e,n,s="numeric"){if(t instanceof xr)return qr(s,t.dtype,e,n),t;let a=(0,r.N)(t);if("string"!==a&&["bool","int32","float32"].indexOf(s)>=0&&(a=s),qr(s,a,e,n),null==t||!(0,r.H)(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const i=Gr(t,a);(0,r.H)(t)||Array.isArray(t)||(t=[t]);const o="string"!==a?ur(t,a):(0,r.h)(t,[],!0);return zr.makeTensor(o,i,a)}function Qr(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,s)=>Zr(t,`${e}[${s}]`,n,r)))}function Jr(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const a=(...t)=>{zr.startScope(n);try{const e=s(...t);return(0,r.i)(e)&&console.error("Cannot return a Promise inside of tidy."),zr.endScope(e),e}catch(t){throw zr.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const Xr=Jr({complex_:function(t,e){const n=Zr(t,"real","complex"),s=Zr(e,"imag","complex");(0,r.e)(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const a={real:n,imag:s};return zr.runKernel(ht,a)}});function Yr(t,e,n,s){if(null==s&&(s=(0,r.N)(t)),"complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!(0,r.H)(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){(0,r.S)(e);const t=(0,r.s)(e),s=(0,r.s)(n);(0,r.a)(t===s,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${s}`));for(let t=0;t<n.length;++t){const s=n[t],a=t!==n.length-1||s!==(0,r.s)(e.slice(t));(0,r.a)(n[t]===e[t]||!a,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return(0,r.H)(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==s?ur(t,s):(0,r.h)(t,[],!0),zr.makeTensor(t,e,s)}function ts(t,e,n){return Yr(t,e,Gr(t,n),n)}function es(t,e="float32",n){return e=e||"float32",(0,r.S)(t),new vr(t,e,n)}const ns=Jr({cast_:function(t,e){const n=Zr(t,"x","cast");if(!(0,r.F)(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const s={x:n},a={dtype:e};return zr.runKernel(lt,s,a)}}),rs=Jr({clone_:function(t){const e={x:Zr(t,"x","clone","string_or_numeric")};return zr.runKernel(Qt,e)}});function ss(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=t[a]||1;(e[e.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function as(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],a=e.length-r-1,i=e[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function is(t,e){const n=[],r=Math.max(t.length,e.length);for(let s=0;s<r;s++){let r=t[t.length-s-1];null==r&&(r=1);let a=e[e.length-s-1];if(null==a&&(a=1),1===r)n.unshift(a);else if(1===a)n.unshift(r);else{if(r!==a)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(r)}}return n}function os(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(a+" update.rank != "+(s+t.length-r));for(let t=0;t<s;++t)if(n.shape[t]!==e.shape[t])throw new Error(a+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-s;++e)if(n.shape[e+s]!==t[e+r])throw new Error(a+` updates.shape[${e+s}] (${n.shape[e+s]}) != shape[${e+s}] (${t[e+s]})`)}function ls(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}os(n,e,t)}function cs(t,e,n){const s=e.shape.length,a=s>1?e.shape[s-1]:1,i=n.length;let o=1;for(let t=a;t<i;++t)o*=n[t];const l=a<1?1:a;return{sliceRank:a,numUpdates:(0,r.s)(e.shape)/l,sliceSize:o,strides:[...(0,r.P)(n.slice(0,a)),1],outputSize:(0,r.s)(n)}}const us=Jr({mul_:function(t,e){let n=Zr(t,"a","mul"),r=Zr(e,"b","mul");[n,r]=Pr(n,r);const s={a:n,b:r};return zr.runKernel(xe,s)}});function hs(t,e,n,r,s="NHWC",a){return ps(t,[...e,t[3]],n,a,r,null,null,Ts(s))}function ds(t,e,n,r,s,a,i="channelsLast"){const[o,l]=ys(e);let c;if("channelsLast"===i)c=[o,l,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);c=[o,l,t[1],t[1]]}return ps(t,c,n,r,s,a,!1,i)}function fs(t,e,n,r,s,a,i="NDHWC"){const[o,l,c]=bs(e);let u,h;if("NDHWC"===i)h="channelsLast",u=[o,l,c,t[4],t[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);h="channelsFirst",u=[o,l,c,t[1],t[1]]}return gs(t,u,n,r,s,!1,h,a)}function ps(t,e,n,r,s,a,i=!1,o="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if("channelsLast"===o)[l,c,u,h]=t;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,c,u]=t}const[d,f,,p]=e,[g,m]=ys(n),[y,b]=ys(r),k=ks(d,y),w=ks(f,b),{padInfo:I,outHeight:v,outWidth:T}=function(t,e,n,r,s,a,i,o,l){let c,u,h;if("number"==typeof t){c={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,r,s){null==r&&(r=ms(t,e,n));const a=t[1];return[ws((t[0]-e+2*r)/n+1,s),ws((a-e+2*r)/n+1,s)]}([e,n],a,r,t,o);u=s[0],h=s[1]}else if("same"===t){u=Math.ceil(e/r),h=Math.ceil(n/s);const t=Math.max(0,(u-1)*r+a-e),o=Math.max(0,(h-1)*s+i-n),l=Math.floor(t/2),d=t-l,f=Math.floor(o/2);c={top:l,bottom:d,left:f,right:o-f,type:"SAME"}}else if("valid"===t)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-a+1)/r),h=Math.ceil((n-i+1)/s);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===l?t[1][0]:t[2][0],f="channelsLast"===l?t[1][1]:t[2][1],p="channelsLast"===l?t[2][0]:t[3][0],g="channelsLast"===l?t[2][1]:t[3][1];c={top:d,bottom:f,left:p,right:g,type:0===d&&0===f&&0===p&&0===g?"VALID":"EXPLICIT"},u=ws((e-a+d+f)/r+1,o),h=ws((n-i+p+g)/s+1,o)}}return{padInfo:c,outHeight:u,outWidth:h}}(s,c,u,g,m,k,w,a,o),$=i?p*h:p;let E;return"channelsFirst"===o?E=[l,$,v,T]:"channelsLast"===o&&(E=[l,v,T,$]),{batchSize:l,dataFormat:o,inHeight:c,inWidth:u,inChannels:h,outHeight:v,outWidth:T,outChannels:$,padInfo:I,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:f,effectiveFilterHeight:k,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:t,outShape:E,filterShape:e}}function gs(t,e,n,r,s,a=!1,i="channelsLast",o){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,c,u,h,d]=t;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,d,c,u,h]=t}const[f,p,g,,m]=e,[y,b,k]=bs(n),[w,I,v]=bs(r),T=ks(f,w),$=ks(p,I),E=ks(g,v),{padInfo:x,outDepth:S,outHeight:F,outWidth:D}=function(t,e,n,r,s,a,i,o,l,c,u){let h,d,f,p;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const a=function(t,e,n,r,s,a){null==s&&(s=ms(t,e,r));const i=t[1],o=t[2];return[ws((t[0]-e+2*s)/r+1,a),ws((i-e+2*s)/r+1,a),ws((o-e+2*s)/r+1,a),1]}([e,n,r,1],o,0,s,t,u);d=a[0],f=a[1],p=a[2]}else if("same"===t){d=Math.ceil(e/s),f=Math.ceil(n/a),p=Math.ceil(r/i);const t=(d-1)*s+o-e,u=(f-1)*a+l-n,g=(p-1)*i+c-r,m=Math.floor(t/2),y=t-m,b=Math.floor(u/2),k=u-b,w=Math.floor(g/2);h={top:b,bottom:k,left:w,right:g-w,front:m,back:y,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-o+1)/s),f=Math.ceil((n-l+1)/a),p=Math.ceil((r-c+1)/i)}return{padInfo:h,outDepth:d,outHeight:f,outWidth:p}}(s,c,u,h,y,b,k,T,$,E,o),B=a?m*d:m;let A;return"channelsFirst"===i?A=[l,B,S,F,D]:"channelsLast"===i&&(A=[l,S,F,D,B]),{batchSize:l,dataFormat:i,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:S,outHeight:F,outWidth:D,outChannels:B,padInfo:x,strideDepth:y,strideHeight:b,strideWidth:k,filterDepth:f,filterHeight:p,filterWidth:g,effectiveFilterDepth:T,effectiveFilterHeight:$,effectiveFilterWidth:E,dilationDepth:w,dilationHeight:I,dilationWidth:v,inShape:t,outShape:A,filterShape:e}}function ms(t,e,n,r=1){const s=ks(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function ys(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function bs(t){return"number"==typeof t?[t,t,t]:t}function ks(t,e){return e<=1?t:t+(t-1)*(e-1)}function ws(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function Is(t){const[e,n,r]=ys(t);return 1===e&&1===n&&1===r}function vs(t,e){return Is(t)||Is(e)}function Ts(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function $s(t,e,n){if(null!=n){if("string"==typeof e)throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if("number"==typeof e)(0,r.a)((0,r.c)(e),(()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`));else{if("object"!=typeof e)throw Error(`Error in ${t}: Unknown padding parameter: ${e}`);e.forEach((e=>{e.forEach((e=>{(0,r.a)((0,r.c)(e),(()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`))}))}))}}}const Es=Jr({reshape_:function(t,e){const n={x:Zr(t,"x","reshape","string_or_numeric")},r={shape:e};return zr.runKernel(Ue,n,r)}}),xs=Jr({sigmoid_:function(t){const e={x:Zr(t,"x","sigmoid","float32")};return zr.runKernel(an,e)}}),Ss=Jr({elu_:function(t){const e={x:Zr(t,"x","elu","float32")};return zr.runKernel(Nt,e)}}),Fs=Jr({leakyRelu_:function(t,e=.2){const n={x:Zr(t,"x","leakyRelu")},r={alpha:e};return zr.runKernel(ne,n,r)}}),Ds=Jr({sum_:function(t,e=null,n=!1){let r=Zr(t,"x","sum");"bool"===r.dtype&&(r=ns(r,"int32"));const s={x:r},a={axis:e,keepDims:n};return zr.runKernel(cn,s,a)}});function Bs(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function As(t,e,n){const r=t.length+e.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(t[a++]):s.push(e[i++]);return s}function Ms(t,e){const n=[],r=t.length;for(let s=0;s<r;s++)-1===e.indexOf(s)&&n.push(t[s]);return[n,e.map((e=>t[e]))]}function Ns(t,e){return As(t,e.map((t=>1)),e)}function Rs(t,e,n){(0,r.a)(Bs(e,n),(()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`))}function Cs(t,e){if(Bs(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function Ps(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function Ls(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}const _s=Jr({prelu_:function(t,e){const n={x:Zr(t,"x","prelu"),alpha:Zr(e,"alpha","prelu")};return zr.runKernel(Le,n)}}),Os=Jr({relu_:function(t){const e={x:Zr(t,"x","relu")};return zr.runKernel(je,e)}}),Vs=Jr({relu6_:function(t){const e={x:Zr(t,"x","relu6")};return zr.runKernel(qe,e)}}),Ks=Jr({step_:function(t,e=0){const n={x:Zr(t,"x","step")},r={alpha:e};return zr.runKernel(Cn,n,r)}});function js(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return us(t,Ks(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Us(t,e){let n=e;const r=as(t.shape,e.shape);return r.length>0&&(n=Ds(n,r)),Es(n,t.shape)}function zs(t,e,n,r){if("linear"===e)return t;if("relu"===e)return Os(t);if("elu"===e)return Ss(t);if("relu6"===e)return Vs(t);if("prelu"===e)return _s(t,n);if("leakyrelu"===e)return Fs(t,r);if("sigmoid"===e)return xs(t);throw new Error(`Unknown fused activation ${e}.`)}const Hs=(t,e)=>!(t>0)||"linear"===e}}]);